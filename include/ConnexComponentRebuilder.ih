#define Y_ADJ( voxel, neighbor ) (voxel).at(1) + (neighbor/9-1)
#define X_ADJ( voxel, neighbor ) (voxel).at(0) + ( (neighbor%9)/3 -1 )
#define Z_ADJ( voxel, neighbor ) (voxel).at(2) + ( neighbor % 3 -1 )

bool g_debug = false ;

template <typename E> bool listcmp( const QList< E > &a, const QList< E > &b, uint position ) {
	if ( a.size() <= position || b.size() <= position ) return false ;
	uint k = 0 ;
	while ( k <= position ) {
		if ( a.at(k) != b.at(k) ) return false ;
		k++ ;
	}
	return true ;
}

template <typename T, typename U, typename V> bool ConnexComponentRebuilder<T,U,V>::sortedListLessThan( const PtrIllDefinedInstance &a, const PtrIllDefinedInstance &b ) {
	if ( a->_seeds.size() < b->_seeds.size() ) return true ;
	if ( a->_seeds.size() > b->_seeds.size() ) return false ;
	uint k = 0 ;
	uint size = a->_seeds.size() ;
	while ( k < size ) {
		if ( a->_seeds.at(k) < b->_seeds.at(k) ) return true ;
		if ( a->_seeds.at(k) > b->_seeds.at(k) ) return false ;
		k++ ;
	}
	return false ;
}

template< typename X> void diff_sorted_list( const QList<X> &a, const char *name_a, const QList<X> &b, const char *name_b ) {
	bool display_once_warning = true ;
	
	bool have_been_displayed_only_a = false ;
	bool have_been_displayed_only_b = false ;
	
	uint cur_a = 0,
	     cur_b = 0,
	     end_a = a.size(),
	     end_b = b.size() ;
	bool are_distinct = false ;
	while ( cur_a != end_a && cur_b != end_b ) {
		if ( a.at( cur_a ) == b.at( cur_b ) ) {
			cur_a++ ;
			cur_b++ ;
		} else if ( a.at( cur_a ) > b.at( cur_b ) ) {
			if ( !display_once_warning || !have_been_displayed_only_b ) {
				have_been_displayed_only_b = true ;
				std::cerr<<"only in "<<name_b<<" : "<<b.at( cur_b )<<std::endl;
				are_distinct = true ;
			}
			cur_b++ ;
		} else {
			if ( !display_once_warning || !have_been_displayed_only_a ) {
				have_been_displayed_only_a = true ;
				std::cerr<<"only in "<<name_a<<" : "<<a.at( cur_a )<<std::endl;
				are_distinct = true ;
			}
			cur_a++ ;
		}
	}
	while ( cur_a != end_a ) {
		if ( !display_once_warning || !have_been_displayed_only_a ) {
			have_been_displayed_only_a = true ;
			std::cerr<<"only in "<<name_a<<" : "<<a.at( cur_a )<<std::endl;
			are_distinct = true ;
		}
		cur_a++ ;
	}
	while ( cur_b != end_b ) {
		if ( !display_once_warning || !have_been_displayed_only_b ) {
			have_been_displayed_only_b = true ;
			std::cerr<<"only in "<<name_b<<" : "<<b.at( cur_b )<<std::endl;
			are_distinct = true ;
		}
		cur_b++ ;
	}
	if ( !are_distinct ) {
		std::cerr<<"same content for "<<name_a<<" and "<<name_b<<std::endl;
	}
}

template <typename T, typename U, typename V> std::string ConnexComponentRebuilder<T,U,V>::IllDefinedInstance::voxels_as_string( ) const {
	std::ostringstream s;
	s << "VI ("<< _idxVoxels.size() <<") : ";
	std::copy( _idxVoxels.begin(), _idxVoxels.end(), std::ostream_iterator< uint >( s, " " ) ) ;
	return s.str() ;
}

template <typename T, typename U, typename V> std::string ConnexComponentRebuilder<T,U,V>::IllDefinedInstance::seeds_as_string( ) const {
	std::ostringstream s;
	s << "Seeds : ";
	std::copy( _seeds.begin(), _seeds.end(), std::ostream_iterator< V >( s, " " ) ) ;
	return s.str() ;
}

template <typename T, typename U, typename V> std::string ConnexComponentRebuilder<T,U,V>::IllDefined::voxels_as_string( ) const {
	std::ostringstream s;
	s << "Voxels ("<< _voxels.size() <<") : ";
	for ( uint k=0;k<_voxels.size() ; k++ )
		s<<" "<<_voxels.at(k).at(0)<<","<<_voxels.at(k).at(1)<<","<<_voxels.at(k).at(2) ;
	return s.str() ;
}

template <typename T, typename U, typename V> bool ConnexComponentRebuilder<T,U,V>::IllDefined::first_child( PtrIllDefinedInstance * inst ) {
	uint i_inst = 0 ;
	while ( i_inst != _instances.size() ) {
		if ( _instances.at( i_inst )->_seeds.size() > (*inst)->_seeds.size() ) {
			bool is_child = true ;
			for ( uint i_seed = 0 ; is_child && i_seed < (*inst)->_seeds.size() ; i_seed++ )
				if ( !_instances.at( i_inst )->_seeds.contains( (*inst)->_seeds.at( i_seed ) ) ) is_child = false ;
			if ( is_child ) {
				*inst = _instances.at( i_inst ) ;
				return true ;
			}
		}
		i_inst++ ;
	}
	return false ;
}

template <typename T, typename U, typename V> bool ConnexComponentRebuilder<T,U,V>::IllDefined::next_child( const PtrIllDefinedInstance father, PtrIllDefinedInstance * child ) {
	uint i_inst = 0 ;
	
	while ( _instances.at( i_inst ) != *child )
		i_inst++ ;
	i_inst++ ;
	while ( i_inst != _instances.size() ) {
		if ( _instances.at( i_inst )->_seeds.size() > father->_seeds.size() ) {
			bool is_child = true ;
			for ( uint i_seed = 0 ; is_child && i_seed < father->_seeds.size() ; i_seed++ )
				if ( !_instances.at( i_inst )->_seeds.contains( father->_seeds.at( i_seed ) ) ) is_child = false ;
			if ( is_child ) {
				*child =  _instances.at( i_inst ) ;
				return true ;
			}
		}
		i_inst++ ;
	}
	return false ;
}

template <typename T, typename U, typename V> ConnexComponentRebuilder<T,U,V>::~ConnexComponentRebuilder( ) {
	if ( _allocated_depth ) delete _depth ;
	
	for ( QMap< uint32_t, LayerType >::Iterator iter = _layers.begin() ; iter != _layers.end() ; iter++ ) {
		delete iter.value().first ;	/// digitalset
		delete iter.value().second ;/// domain
	}
}

template <typename T, typename U, typename V> bool ConnexComponentRebuilder<T,U,V>::setDepth( BillonTpl< U > *depth ) {
	if ( _depth ) {
		if ( _allocated_depth ) delete _depth ;
	}
	_depth = depth ;
	_allocated_depth = false ;
	if ( _depth->n_rows != _n_rows || _depth->n_cols != _n_cols || _depth->n_slices != _n_slices ) {
		std::cerr<<"Warning : depth image's size ["<< _depth->n_rows<<" x "<< _depth->n_cols<<" x "<<_depth->n_slices<<"] is not equal"
				<<"to labelled skeleton image's size ["<<_n_rows<<" x "<<_n_cols<<" x "<<_n_slices<<"]"<<std::endl;
		return false ;
	}
	return true ;
}

template <typename T, typename U, typename V> bool ConnexComponentRebuilder<T,U,V>::setDepth( const QString & depthFileName ) {
	if ( _depth ) {
		if ( _allocated_depth ) delete _depth ;
	}
	Pgm3dFactory< U > factory ;
	_depth = factory.read( depthFileName ) ;
	factory.correctEncoding( _depth ) ;
	_allocated_depth = true ;
	if ( _depth->n_rows != _n_rows || _depth->n_cols != _n_cols || _depth->n_slices != _n_slices ) {
		std::cerr<<"Warning : depth image's size ["<< _depth->n_rows<<" x "<< _depth->n_cols<<" x "<<_depth->n_slices<<"] is not equal"
				<<"to labelled skeleton image's size ["<<_n_rows<<" x "<<_n_cols<<" x "<<_n_slices<<"]"<<std::endl;
		return false ;
	}
	_depthfile = depthFileName ;
	return true ;
}

template <typename T, typename U, typename V> bool ConnexComponentRebuilder<T,U,V>::setBounds( uint32_t selection ) {
	if ( !_depth ) return false ;
		
	Point 	lower=_layers[ selection ].second->lowerBound(),
			upper=_layers[ selection ].second->upperBound() ;
	const DigitalSet * pts = _layers[ selection ].first ;
	for ( DigitalSet::ConstIterator pt = pts->begin() ; pt != pts->end(); pt++ ) {
		U d = floor( 1.+sqrt( double( (*_depth)( (*pt).at(1),(*pt).at(0),(*pt).at(2) ) ) ) ) ;
		if ( (U)pt->at(0) - d < (U)lower.at(0) ) lower.at(0) = (U)pt->at(0) - d ;
		if ( (U)pt->at(1) - d < (U)lower.at(1) ) lower.at(1) = (U)pt->at(1) - d ;
		if ( (U)pt->at(2) - d < (U)lower.at(2) ) lower.at(2) = (U)pt->at(2) - d ;
		if ( (U)pt->at(0) + d > (U)upper.at(0) ) upper.at(0) = (U)pt->at(0) + d ;
		if ( (U)pt->at(1) + d > (U)upper.at(1) ) upper.at(1) = (U)pt->at(1) + d ;
		if ( (U)pt->at(2) + d > (U)upper.at(2) ) upper.at(2) = (U)pt->at(2) + d ;
	}
	_lower[ selection ] = lower ;
	_upper[ selection ] = upper ;
	
/// explain the bounds being found
for ( DigitalSet::ConstIterator pt = pts->begin() ; false && pt != pts->end(); pt++ ) {
	if ( lower.at(0) == pt->at(0) - (*_depth)( (*pt).at(1),(*pt).at(0),(*pt).at(2) ) ) std::cout<<"Xmin "<<lower.at(0)<<"="<<pt->at(0)<<"-"<<(*_depth)( (*pt).at(1),(*pt).at(0),(*pt).at(2) )<<std::endl;
	if ( lower.at(1) == pt->at(1) - (*_depth)( (*pt).at(1),(*pt).at(0),(*pt).at(2) ) ) std::cout<<"Ymin "<<lower.at(1)<<"="<<pt->at(1)<<"-"<<(*_depth)( (*pt).at(1),(*pt).at(0),(*pt).at(2) )<<std::endl;
	if ( lower.at(2) == pt->at(2) - (*_depth)( (*pt).at(1),(*pt).at(0),(*pt).at(2) ) ) std::cout<<"Zmin "<<lower.at(2)<<"="<<pt->at(2)<<"-"<<(*_depth)( (*pt).at(1),(*pt).at(0),(*pt).at(2) )<<std::endl;
	if ( upper.at(0) == pt->at(0) + (*_depth)( (*pt).at(1),(*pt).at(0),(*pt).at(2) ) ) std::cout<<"Xmax "<<upper.at(0)<<"="<<pt->at(0)<<"+"<<(*_depth)( (*pt).at(1),(*pt).at(0),(*pt).at(2) )<<std::endl;
	if ( upper.at(1) == pt->at(1) + (*_depth)( (*pt).at(1),(*pt).at(0),(*pt).at(2) ) ) std::cout<<"Ymax "<<upper.at(1)<<"="<<pt->at(1)<<"+"<<(*_depth)( (*pt).at(1),(*pt).at(0),(*pt).at(2) )<<std::endl;
	if ( upper.at(2) == pt->at(2) + (*_depth)( (*pt).at(1),(*pt).at(0),(*pt).at(2) ) ) std::cout<<"Zmax "<<upper.at(2)<<"="<<pt->at(2)<<"+"<<(*_depth)( (*pt).at(1),(*pt).at(0),(*pt).at(2) )<<std::endl;
}
	return true ;
}

template <typename T, typename U, typename V> ConnexComponentRebuilder<T,U,V>::ConnexComponentRebuilder( const BillonTpl<T> & img, QList< T > *ignoring ) : _result( img.n_rows, img.n_cols, img.n_slices ) {
	_n_labels = img.max() + 1 ;
	_depth = 0 ;
	_allocated_depth = false ;
	_n_rows = img.n_rows ;
	_n_cols = img.n_cols ;
	_n_slices = img.n_slices ;
	_result.fill(0);
	init( img, ignoring ) ;
}

template <typename T, typename U, typename V> ConnexComponentRebuilder<T,U,V>::ConnexComponentRebuilder( const QString & lblSkelFileName, QList< T > *ignoring ) {
	
	Pgm3dFactory< T > factory ;
	BillonTpl< T > * pimg = factory.read( lblSkelFileName ) ;
	_n_labels = pimg->max() + 1 ;
	_depth = 0 ;
	_allocated_depth = false ;
	_n_rows = pimg->n_rows ;
	_n_cols = pimg->n_cols ;
	_n_slices = pimg->n_slices ;
	_result = BillonTpl<V>( _n_rows, _n_cols, _n_slices ) ;
	_result.fill(0);
	init( *pimg, ignoring ) ;
	delete pimg ;
}

template <typename T, typename U, typename V> void ConnexComponentRebuilder<T,U,V>::init( const BillonTpl< T > &img, QList< T > *ignoring ) {
	Point *lower = new Point [ _n_labels ] ;
	Point *upper = new Point [ _n_labels ] ;
	uint32_t label ;
	for ( label = 1 ; label < _n_labels ; label++ ) {
		lower[ label ] = Point ( _n_cols, _n_rows, _n_slices ) ;
		upper[ label ] = Point ( 0, 0, 0 ) ;
	}

	QList< iCoord3D > *pts = new QList< iCoord3D > [ _n_labels ] ;
	register int x,y,z ;
	for ( z = 0 ; z < _n_slices ; z++ )
		for ( x = 0 ; x < _n_cols ; x++ )
			for ( y = 0 ; y < _n_rows ; y++ ) {
				label = img(y,x,z) ;
				if ( label == 0 ) continue ;
				if ( ignoring && ignoring->contains( label ) ) {
					continue ;
				}
				pts[ label ].append( iCoord3D(x,y,z) ) ;
				lower[ label ].at(0) = std::min( lower[ label ].at(0), x ) ;
				lower[ label ].at(1) = std::min( lower[ label ].at(1), y ) ;
				lower[ label ].at(2) = std::min( lower[ label ].at(2), z ) ;
				upper[ label ].at(0) = std::max( upper[ label ].at(0), x ) ;
				upper[ label ].at(1) = std::max( upper[ label ].at(1), y ) ;
				upper[ label ].at(2) = std::max( upper[ label ].at(2), z ) ;
			}
	
	for ( label = 1 ; label < _n_labels ; label++ ) {
		LayerType layer ;
		if ( pts[ label ].isEmpty() ) {
			layer.second = 0 ;
			layer.first = 0 ;
			_layers[ label ] = layer ;
			continue ;
		}
		layer.second = new Domain( lower[label], upper[label] ) ;
		layer.first  = new DigitalSet( * layer.second ) ;
		_layers[ label ] = layer ;
		while ( !pts[ label ].empty() ) {
			iCoord3D aPoint = pts[ label ].takeAt(0);
			layer.first->insertNew( Point( aPoint.x,aPoint.y, aPoint.z ) ) ;
		}
	}
	delete [] lower ;
	delete [] upper ;

	/// adjacency relations
	uint32_t adj_label ;
	register int n ;
	for ( uint32_t label = 1 ; label < _n_labels ; label++ ) {
		const DigitalSet *pts = _layers[ label ].first ;
		if ( pts == 0 ) continue ;
		for ( DigitalSet::Iterator pt = pts->begin() ; pt != pts->end() ; pt++ )
			for ( n = 0 ; n < 27 ; n++ ) {
				if ( n == 13 ) continue ; /// this is *pt
				x = X_ADJ( *pt, n ) ;
				if ( x < 0 || x == _n_cols ) continue ;
				y = Y_ADJ( *pt, n ) ;
				if ( y < 0 || y == _n_rows ) continue ;
				z = Z_ADJ( *pt, n ) ;
				if ( z < 0 || z == _n_slices ) continue ;
				adj_label = img(y,x,z) ;
				if ( adj_label <= label ) continue ;
				if ( _layers[ adj_label ].first == 0 ) continue ;
				
				uint32_t key = label * _n_labels + adj_label ;
				if ( !_adjacency.contains( label ) ) _adjacency.insert( label, QSet<uint32_t>() ) ;
				if ( !_adjacency[ label ].contains( adj_label ) ) {
					_adjacency[ label ].insert( adj_label ) ;
					_locations.insert( key, QList< VoxelsPair > () ) ;
				}
				_locations[ key ].append( VoxelsPair( *pt, Point(x,y,z) ) ) ;
				if ( !_adjacency.contains( adj_label ) ) _adjacency.insert( adj_label, QSet<uint32_t>() ) ;
				if ( !_adjacency[ adj_label ].contains( label ) ) {
					_adjacency[ adj_label ].insert( label ) ;
				}
			}
	}


}

/**
 * \brief retrieve from the input set, the instance (father) being equal to elem (child) but the missing element
 * \param [in] inst : the input set
 * \param [in] seeds : the content of the child
 * \param [in] missing : the label of the region that is omitted in the father
 * \return the specific father of seeds
 */
template <typename T, typename U, typename V> uint ConnexComponentRebuilder<T,U,V>::index_of_parent( const QList < PtrIllDefinedInstance > & inst, const QList<V> &seeds, uint missing, bool &correct ) {
	uint i_begin = 0 ;
	uint i_end = inst.size() ;
	uint length = seeds.size() - 1 ;
	correct = false ;

	while ( i_begin != i_end ) {
		PtrIllDefinedInstance father = inst.at( i_begin ) ;
		
//std::cout<<"Candidate "<<__FUNCTION__<<" "<< father->seeds_as_string()<<std::endl;
		
		if ( father->_seeds.size() == length ) {
			uint iSeedChild = 0 ;
			uint iSeed ;
			for ( iSeed = 0 ; iSeed < length ; iSeed++ ) {
				if ( seeds.at( iSeed ) == missing ) {
					iSeedChild++ ;
				}
				if ( father->_seeds.at( iSeed ) != seeds.at( iSeedChild ) ) {
//					std::cout<<"\t\tno (value)"<<std::endl;
					break ;
				} else {
					iSeedChild++ ;
				}
			}
			if ( iSeed == length ) {
//				std::cout<<"\t\tyes"<<std::endl;
				correct = true ;
				return i_begin ;
			}
		} else {
//			std::cout<<"\t\tno (size)"<<std::endl;
		}
		i_begin++ ;
	}
	return 0 ;
}

/**
 * \brief retrieve from the input set, the instance (father) being equal to elem (child) but the missing element
 * \param [in] inst : the input set
 * \param [in] elem : the child
 * \param [in] missing : the label of the region that is omitted in the father
 * \return the specific father of elem
 */
template <typename T, typename U, typename V> uint ConnexComponentRebuilder<T,U,V>::index_of_parent( const QList < PtrIllDefinedInstance > & inst, const PtrIllDefinedInstance elem, uint missing, bool &correct ) {
	return index_of_parent( inst, elem->_seeds, missing,correct ) ;
}

template <typename T, typename U, typename V> 
void ConnexComponentRebuilder<T,U,V>::translate_idxVoxel( const QList< uint > &idx_voxels, uint32_t ref, uint32_t newref, QList< uint > &idx_voxels_tr ) {
	uint number = idx_voxels.size() ;
	Point voxel ;
	const IllDefined &refCC = _illDefined[ ref ] ;
	const IllDefined &newRefCC = _illDefined[ newref ] ;
	for ( uint i = 0 ; i < number ; i++ ) {
		voxel = refCC._voxels.at( idx_voxels.at( i ) ) ;
		int j = newRefCC._voxels.indexOf( voxel ) ;
		if ( j != -1 ) {
			assert( voxel == newRefCC._voxels.at( j ) ) ;
			idx_voxels_tr.append( (uint) j ) ;
		} else {
			std::cerr<<"[Error] : can not translate into new reference"<<std::endl;
		}
	}
	qSort( idx_voxels_tr ) ;
}

template <typename T, typename U, typename V> 
bool ConnexComponentRebuilder<T,U,V>::split_voxels( PtrIllDefinedInstance father, const QList< uint > &childVoxels ) {
	bool display_once_warning = true ;
	
	bool have_been_displayed = false ;
	uint i_child = 0,
	     i_father = 0,
	     end_child = childVoxels.size() ;
	
	for ( ; i_child != end_child ; i_child++ ) {
		while ( father->_idxVoxels.at( i_father ) < childVoxels.at( i_child ) ) {
			i_father++ ;
			if( i_father == father->_idxVoxels.size() ) break ;
		}
		if ( i_father == father->_idxVoxels.size() ) break ;
		if ( father->_idxVoxels.at( i_father ) == childVoxels.at( i_child ) ) {
			father->_idxVoxels.takeAt( i_father ) ;
			if ( i_father == father->_idxVoxels.size() ) {
				i_child++ ;
				break ;
			}
		} else {
			if ( !display_once_warning || !have_been_displayed ) {
				have_been_displayed = true ;
				std::cerr<<"Warning : can not remove voxel "<<childVoxels.at( i_child )<<" ["<< _illDefined[ father->_seeds.at(0)]._voxels.at(childVoxels.at( i_child ))<<"] from Region("<< father->seeds_as_string() ;
				std::cerr<<") being on "<< father->_idxVoxels.at( i_father )<<std::endl;
			}
			//i_father++ ;
		}
	}
	return ( i_child == end_child ) ;
}

template <typename T, typename U, typename V> 
bool ConnexComponentRebuilder<T,U,V>::split_voxels( PtrIllDefinedInstance father, const PtrIllDefinedInstance child ) {
	return split_voxels( father, child->_idxVoxels ) ;
}

template <typename T, typename U, typename V> void ConnexComponentRebuilder<T,U,V>::explicit_intersection( const PtrIllDefinedInstance inst ) {

	QList< uint32_t > Seeds = inst->_seeds ;
	uint i_seed = 0,
	     n_seed = Seeds.size() ;
	QList< Point > inter_voxels( _illDefined[ Seeds.at(0) ]._voxels );
	i_seed++ ;
	
	/// compute the overall intersection from the voxel viewpoint
	for ( ; i_seed != n_seed; i_seed++ ) {
		const QList< Point > & comp_voxels = _illDefined[ Seeds.at( i_seed ) ]._voxels ;
		uint cur_inter = 0,
		     cur_comp = 0,
		     end_comp = comp_voxels.size() ;
		while ( cur_inter != inter_voxels.size() && cur_comp != end_comp ) {
			if ( inter_voxels.at( cur_inter ) == comp_voxels.at( cur_comp ) ) {
				cur_inter++ ;
				cur_comp++ ;
			} else if ( inter_voxels.at( cur_inter ) > comp_voxels.at( cur_comp ) ) {
				cur_comp++ ;
			} else {
				inter_voxels.removeAt( cur_inter ) ;
			}
		}
		while ( cur_inter != inter_voxels.size() )
			inter_voxels.removeAt( cur_inter ) ;
	}
	Seeds.clear() ;
	std::cerr<<inst->seeds_as_string()<<std::endl;
	/// if inst has children, shrink this list
	PtrIllDefinedInstance inst_child = const_cast<PtrIllDefinedInstance>( inst );
	if ( _illDefined[ inst->_seeds.at(0) ].first_child( &inst_child ) ) {
		do {
			std::cerr<<"\t\thas child "<<inst_child->seeds_as_string()<<std::endl;
			Seeds.append( inst_child->_seeds ) ;
		} while ( _illDefined[ inst->_seeds.at(0) ].next_child( inst, &inst_child ) ) ;
		qSort( Seeds ) ;
		for ( uint k=0 ; k < Seeds.size()-1 ; ) {
			if ( Seeds.at(k) == Seeds.at(k+1) )
				Seeds.removeAt( k+1 ) ;
			else
				k++ ;
		}
		
		for ( i_seed = 0 ; i_seed != n_seed; i_seed++ ) {
			const QList< Point > & comp_voxels = _illDefined[ Seeds.at( i_seed ) ]._voxels ;
			uint cur_inter = 0,
				 cur_comp = 0,
				 end_comp = comp_voxels.size() ;
			while ( cur_inter != inter_voxels.size() && cur_comp != end_comp ) {
				if ( inter_voxels.at( cur_inter ) == comp_voxels.at( cur_comp ) ) {
					inter_voxels.removeAt( cur_inter ) ;
					cur_comp++ ;
				} else if ( inter_voxels.at( cur_inter ) > comp_voxels.at( cur_comp ) ) {
					cur_comp++ ;
				} else {
					cur_inter++ ;
				}
			}
		}
		
	}

	
	
	/// translate the result into indices wrt the first seed's voxels
	QList< uint > inter_indices ;
	const QList< Point > & ref = _illDefined[ inst->_seeds.at(0) ]._voxels ;
	uint cur_ref = 0,
	     cur_read = 0,
	     end_read = inter_voxels.size() ;
	for ( ; cur_read != end_read ; cur_read++ ) {
		Point pt = inter_voxels.at( cur_read ) ;
		while ( ref.at( cur_ref ) != pt ) cur_ref++ ;
		inter_indices.append( cur_ref ) ;
	}
	diff_sorted_list( inter_indices, "rebuild", inst->_idxVoxels, "instance" ) ;
	
}

template <typename T, typename U, typename V> void ConnexComponentRebuilder<T,U,V>::post_processing( ) {
	if ( _illDefined.empty() ) return ;
	
	QList< PtrIllDefinedInstance > priorityProblem ;
	typename QList< PtrIllDefinedInstance >::Iterator problem ;
	QMap< uint32_t, uint32_t > penaltyVolume ;
	for ( typename QMap< uint32_t, IllDefined >::ConstIterator iter= _illDefined.begin();iter!= _illDefined.end();iter++ ) {
		/// seed's connected components are sorted in descending order of their size (pessimistic value)
		penaltyVolume[ iter.key() ] = iter.value()._voxels.size() ;
		
		/// problems are sorted in descending order of their size
		for ( uint k = 0 ; k < iter.value()._instances.size() ; k++ ) {
			PtrIllDefinedInstance p_inst = iter.value()._instances.at( k ) ;
			if ( p_inst->_seeds.at(0) != iter.key() ) continue ;
			problem = priorityProblem.begin() ;

			while ( problem != priorityProblem.end() ) {
				if ( p_inst->_idxVoxels.size() > (*problem)->_idxVoxels.size() ) break ;
				problem++ ;
			}
			priorityProblem.insert( problem, p_inst ) ;			
		}
	}
	while ( ! priorityProblem.isEmpty() ) {
		PtrIllDefinedInstance p_inst = priorityProblem.takeAt(0) ;
		uint winner = p_inst->_seeds.at(0) ;
		const QList< Point > &L = _illDefined[ winner ]._voxels ;
		for ( uint s = 1 ; s < p_inst->_seeds.size() ; s++ ) {
			if ( _volumes[ winner ] - penaltyVolume[ winner ] < _volumes[ p_inst->_seeds.at(s) ] - penaltyVolume[ p_inst->_seeds.at(s) ] )
				winner = p_inst->_seeds.at(s) ;
		}

		for ( uint v = 0 ; v < p_inst->_idxVoxels.size() ; v++ ) {
			Point voxel = L.at( p_inst->_idxVoxels.at(v) ) ;
			_result( voxel.at(1),voxel.at(0),voxel.at(2) ) = winner ;
		}
		 
		QList< V > Seeds = p_inst->_seeds ;
		uint extra = p_inst->_idxVoxels.size() ;
		for ( uint s = 0 ; s < Seeds.size() ; s++ ) {
			penaltyVolume[ Seeds.at(s) ] -= extra ;
			if ( Seeds.at(s) != winner )
				_volumes[ Seeds.at(s) ] -= extra ;
			_illDefined[ Seeds.at(s) ]._instances.removeOne( p_inst ) ;
			if ( _illDefined[ Seeds.at(s) ]._instances.isEmpty() ) _illDefined[ Seeds.at(s) ]._voxels.clear() ;
		}
		delete p_inst ;
	 }
	/// remove empty regions
	for ( typename QMap< V, IllDefined >::Iterator iter = _illDefined.begin() ; iter != _illDefined.end() ;  ) { 
		if ( _volumes[ iter.key() ] == 0 ) {
			_volumes.remove( iter.key() ) ;
			iter = _illDefined.erase( iter ) ;
		} else
			iter++ ;
	}
}

template <typename T, typename U, typename V> bool ConnexComponentRebuilder<T,U,V>::run( bool storeOverlaping ) {
	for ( uint32_t label = 1 ; label < _n_labels ; label++ ) {
		if ( _layers[ label ].first == 0 ) continue ;
		if ( !run( label, label, storeOverlaping ) ) return false ;
	}
	if ( !storeOverlaping ) return true ;
	QList< IllDefinedInstance * > instances ;
#ifdef USE_MAP_FIRST_LABEL

	/// add shadow transitions
	for ( QMap< uint32_t, QMap< uint32_t, QList< Point > > >::Iterator source = _sharedVoxels.begin() ; source != _sharedVoxels.end() ; source++ ) {
		QList< uint32_t > Targets ;
		for ( QMap< uint32_t, QList< Point > >::ConstIterator target = source.value().begin() ; target != source.value().end() ; target++ )
			Targets.append( target.key() ) ;
if ( source.key() == 13 ) {
std::cerr<<"13's targets : ";std::copy( Targets.begin(),Targets.end(),std::ostream_iterator<uint32_t>( std::cerr, " " ) ) ;std::cerr<<std::endl;
}
		for ( uint tmp_source = 0 ; tmp_source < Targets.size()-1 ; tmp_source++ )
			for ( uint tmp_target = tmp_source+1 ; tmp_target < Targets.size() ; tmp_target++ ) {
				QList< Point > inter_voxels = source.value()[ Targets.at(tmp_source) ] ;
				const QList< Point > & comp_voxels = source.value()[ Targets.at(tmp_target) ] ;
if ( source.key() == 13 ) {
	if ( Targets.at(tmp_source) == 19 && Targets.at(tmp_target) == 20 ) {
		std::cerr<<"13|19 : ";std::copy( inter_voxels.begin(),inter_voxels.end(),std::ostream_iterator<Point>( std::cerr, " " ) ) ;std::cerr<<std::endl;
		std::cerr<<"13|20 : ";std::copy( comp_voxels.begin(),comp_voxels.end(),std::ostream_iterator<Point>( std::cerr, " " ) ) ;std::cerr<<std::endl;
	}
}
				uint cur_inter = 0,
				     cur_comp = 0,
				     end_comp = comp_voxels.size() ;
				while ( cur_inter != inter_voxels.size() && cur_comp != end_comp ) {
					if ( inter_voxels.at( cur_inter ) == comp_voxels.at( cur_comp ) ) {
						cur_inter++ ;
						cur_comp++ ;
					} else if ( inter_voxels.at( cur_inter ) > comp_voxels.at( cur_comp ) ) {
						cur_comp++ ;
					} else {
						inter_voxels.removeAt( cur_inter ) ;
					}
				}
				while ( cur_inter != inter_voxels.size() ) {
					inter_voxels.removeAt( cur_inter ) ;
				}
				
if ( source.key() == 13 ) {
	if ( Targets.at(tmp_source) == 19 && Targets.at(tmp_target) == 20 ) {
		std::cerr<<"13|19x20 : ";std::copy( inter_voxels.begin(),inter_voxels.end(),std::ostream_iterator<Point>( std::cerr, " " ) ) ;std::cerr<<std::endl;
	}
}
				
				if ( inter_voxels.isEmpty() ) continue ;
				bool b_is_new = false ;
				if( !_sharedVoxels.contains( Targets.at(tmp_source) ) ) {
					_sharedVoxels.insert( Targets.at(tmp_source), QMap< uint32_t, QList< Point > >() ) ;
					b_is_new = true ;
				}
				if( !_sharedVoxels[ Targets.at(tmp_source) ].contains( Targets.at(tmp_target) ) ) {
					_sharedVoxels[ Targets.at(tmp_source) ].insert( Targets.at(tmp_target), QList< Point >() ) ;
					b_is_new = true ;
				}
				_sharedVoxels[ Targets.at(tmp_source) ][ Targets.at(tmp_target)].append( inter_voxels ) ;
				if ( !b_is_new ) {
					QList< Point > & L = _sharedVoxels[ Targets.at(tmp_source) ][ Targets.at(tmp_target)] ;
					qSort( L ) ;
					/// remove duplicates
					for ( uint k = 0 ; k < L.size()-1 ; k++ ) {
						while ( k+1 < L.size() ) {
							if ( L.at(k+1) == L.at(k) )
								L.removeAt( k+1 ) ;
							else
								break ;
						}
					}
				}
				
				
				if ( b_is_new ) std::cerr<<"[ Info ] : create shadow "<<Targets.at(tmp_source)<<"|"<<Targets.at(tmp_target)<<" wrt "<<source.key()<<std::endl;
				else            std::cerr<<"[ Info ] : update shadow "<<Targets.at(tmp_source)<<"|"<<Targets.at(tmp_target)<<" wrt "<<source.key()<<std::endl;
			}
	}
	
	
	
	for ( QMap< uint32_t, QMap< uint32_t, QList< Point > > >::ConstIterator source = _sharedVoxels.begin() ; source != _sharedVoxels.end() ; source++ ) {
		if ( !_illDefined.contains( source.key() ) )
			_illDefined.insert( source.key(), IllDefined() ) ;
		IllDefined &src = _illDefined[ source.key() ] ;
		for ( QMap< uint32_t, QList< Point > >::ConstIterator target = source.value().begin() ; target != source.value().end() ; target++ ) {
			instances.append( new IllDefinedInstance ) ;
			instances.back()->_seeds.append( source.key() ) ;
			instances.back()->_seeds.append( target.key() ) ;
			qSort( instances.back()->_seeds ) ;
			src._instances.append( instances.back() ) ;
			src._voxels.append( target.value() ) ;
if ( source.key() == 13 || source.key() == 19 || source.key() == 20 ||source.key() == 21 )
	std::cerr<<"[ Info ] : define seed "<<source.key()<<" from "<<source.key()<<"|"<<target.key()<<std::endl;
			
			if ( !_illDefined.contains( target.key() ) )
				_illDefined.insert( target.key(), IllDefined() ) ;

			IllDefined &tgt = _illDefined[ target.key() ] ;
			tgt._instances.append( instances.back() ) ;
			tgt._voxels.append( target.value() ) ;
if ( target.key() == 13 || target.key() == 19 || target.key() == 20 ||target.key() == 21 )
	std::cerr<<"[ Info ] : define seed "<<target.key()<<" from "<<source.key()<<"|"<<target.key()<<std::endl;
		}
	}
	for ( typename QMap< uint32_t, IllDefined >::iterator iter = _illDefined.begin() ; iter != _illDefined.end() ; iter ++ ) {
		qSort( iter.value()._voxels ) ;
		/// remove duplicates
		for ( uint v=0;v<iter.value()._voxels.size(); v++ )
			while ( (v+1) <iter.value()._voxels.size() ) {
				if ( iter.value()._voxels.at(v+1) ==iter.value()._voxels.at(v) )
					iter.value()._voxels.removeAt( v+1 ) ;
				else
					break ;
			}
		
	}

	/// instances having cardinality( _seeds ) = 2
	
	for ( typename QMap< uint32_t, IllDefined >::iterator iter = _illDefined.begin() ; iter != _illDefined.end() ; iter ++ )
		for ( uint i = iter.value()._instances.size() ; i > 0 ; i-- ) {
			if ( iter.value()._instances.at(i-1)->_seeds.at(0) != iter.key() ) continue ;
			IllDefined & other = _illDefined[ iter.value()._instances.at(i-1)->_seeds.at(1) ] ;
			for ( uint v = iter.value()._voxels.size() ; v > 0 ; v-- ) {
				if ( other._voxels.contains( iter.value()._voxels.at( v-1 ) ) ) /// \note not optimal
					iter.value()._instances.at(i-1)->_idxVoxels.insert( 0, v-1 ) ;
			}
		}
	QList<V> dbg_cc ;
	Point dbg_voxel(213, 130, 80 ) ;

	{
		dbg_cc << 13 << 19 << 20 << 21 ;
		for (int cc=0;cc<dbg_cc.size() ; cc++ ) {
			std::cerr<<"DEBUG cc "<<dbg_cc.at(cc)<<" "<<(_illDefined[ dbg_cc.at(cc) ]._voxels.contains( dbg_voxel ) ? " yes":" no")<<std::endl;
			for ( int i_inst = 0 ; i_inst < _illDefined[ dbg_cc.at(cc) ]._instances.size() ; i_inst++ ) {
				if ( dbg_cc.contains( _illDefined[ dbg_cc.at(cc) ]._instances.at( i_inst )->_seeds.at(0) ) &&
					 dbg_cc.contains( _illDefined[ dbg_cc.at(cc) ]._instances.at( i_inst )->_seeds.at(1) ) ) {
					int idx_voxel = _illDefined[ _illDefined[ dbg_cc.at(cc) ]._instances.at( i_inst )->_seeds.at(0) ]._voxels.indexOf( dbg_voxel ) ;
					std::cerr<<"DEBUG "<<_illDefined[ dbg_cc.at(cc) ]._instances.at( i_inst )->seeds_as_string()<<" ... "<<std::endl;
					if ( _illDefined[ dbg_cc.at(cc) ]._instances.at( i_inst )->_idxVoxels.contains( idx_voxel ) )
						std::cerr<<"      \t\tok"<<std::endl;
					else
						std::cerr<<"      \t\tno"<<std::endl;
				}
			}
		}
	}

	/// instances having cardinality( _seeds ) > 2
	bool newInstances = true ;
	
	qSort( instances.begin(), instances.end(), sortedListLessThan ) ;

/// display 9 and 11 instances
for ( uint kk = 9 ; kk <= 11 ; kk += 2 ) {
	std::cout<<"Seed "<<kk<<std::endl;
	for ( uint k = 0 ; k < _illDefined[ kk ]._instances.size() ; k++ )
		std::cout<<"\t"<<_illDefined[ kk ]._instances.at( k )->seeds_as_string()<<std::endl;
}





	uint iBegin = 0,
	     iEnd = instances.size() ;
	while ( iBegin != iEnd ) {
		uint length = instances.at( iBegin )->_seeds.size()-1 ;
		for ( uint i = iBegin ; i < iEnd ; i++ ) {
			IllDefinedInstance * r_instance_i = instances.at( i ) ;
			
			QList< PtrIllDefinedInstance > & inst = _illDefined[ r_instance_i->_seeds.at(0) ]._instances ;
			uint child_begin = inst.size() ;
			QList< uint > idx_child ;
			bool has_child = false ;
			for ( uint j=i+1 ; j < iEnd ; j++ ) {
				IllDefinedInstance * r_instance_j = instances.at( j ) ;
				if ( r_instance_j->_seeds.at(0) != r_instance_i->_seeds.at(0) )
					break ;
				if ( r_instance_j->_seeds.back() <= r_instance_i->_seeds.back() )
					continue ;
				if ( !listcmp<V>( const_cast<const PtrIllDefinedInstance>(r_instance_i)->_seeds, const_cast<const PtrIllDefinedInstance>(r_instance_j)->_seeds, length-1 ) )
					continue ;
				/// the only possibility to define this set
				/// compute the intersection of voxels lists
				QList< uint > idx ;
				uint pos_i = r_instance_i->_idxVoxels.size(),
					 pos_j = r_instance_j->_idxVoxels.size() ;
				bool bDebug = false ;
				if ( r_instance_i->_seeds.size() == 2 && r_instance_j->_seeds.size() == 2 ) {
					bDebug = ( r_instance_i->_seeds.at(0) == 13 && r_instance_i->_seeds.at(1) == 19 && r_instance_j->_seeds.at(1) == 20 ) ;
				}
				if ( bDebug ) {
					std::cerr<<"[ Debug ] : "<<r_instance_i->seeds_as_string()<<std::endl
							<< "            "<<r_instance_i->voxels_as_string()<<std::endl
							<< "            "<<r_instance_j->seeds_as_string()<<std::endl
							<< "            "<<r_instance_j->voxels_as_string()<<std::endl;
				}
				while ( pos_i > 0 && pos_j > 0 ) {
					if ( r_instance_j->_idxVoxels.at( pos_j-1 ) == r_instance_i->_idxVoxels.at( pos_i-1 ) ) {
						idx.insert( 0, r_instance_j->_idxVoxels.at( pos_j-1 ) ) ;
						pos_i-- ;
						pos_j-- ;
					} else if ( r_instance_j->_idxVoxels.at( pos_j-1 ) > r_instance_i->_idxVoxels.at( pos_i-1 ) ) {
						pos_j-- ;
					} else {
						pos_i-- ;
					}
				}
				if ( idx.isEmpty() ) continue ;
if ( !has_child ) {
	/// print father once
	std::cerr<<"Father generates : "<<r_instance_i->seeds_as_string()<<std::endl;
}
				has_child = true ;
				instances.append( new IllDefinedInstance() ) ;
				instances.back()->_seeds = r_instance_i->_seeds ;
				instances.back()->_seeds.append( r_instance_j->_seeds.back() ) ;
				
	/// print generate child
	std::cerr<<"\tChild : "<<instances.back()->seeds_as_string()<<std::endl;
				
				
				
				instances.back()->_idxVoxels = idx ;
				if ( bDebug ) {
					std::cerr<<"[ Debug ] \t\t VI "<<instances.back()->voxels_as_string()<<std::endl;
				}
				
				for ( int k = instances.back()->_seeds.size() ; k > 0 ; k-- ) _illDefined[ instances.back()->_seeds.at(k-1) ]._instances.append( instances.back() ) ;
				
				idx_child.append( idx ) ;
				qSort( idx_child ) ;
				/// remove duplicates
				for ( uint k = 0 ; k < idx_child.size() ; k++ ) {
					while ( k+1 < idx_child.size() ) {
						if ( idx_child.at(k+1) == idx_child.at(k) )
							idx_child.removeAt( k+1 ) ;
						else
							break ;
					}
				}
			}
			
			
		}
		/// now?
		
		if ( iEnd != instances.size() ) {
			uint child_begin = iEnd ;
			uint child_end = instances.size() ;
			bool found ;
			PtrIllDefinedInstance parent ;
			for ( uint child = child_begin ; child != child_end ; child++ ) {
bool watch_dog = true ;
for ( uint i_seed = 0 ; watch_dog && i_seed < instances.at( child )->_seeds.size() ; i_seed++ ) {
	watch_dog = dbg_cc.contains( instances.at( child )->_seeds.at( i_seed ) ) ;
	if (!watch_dog) std::cout<<"\tdo not pay attention as cc "<<instances.at( child )->_seeds.at( i_seed )<<" is there"<<std::endl;
}
				/// print child
				std::cout<<"Child : "<<instances.at( child )->seeds_as_string()<<std::endl;
				QList< PtrIllDefinedInstance > & inst = _illDefined[instances.at( child )->_seeds.at(0) ]._instances ;
				uint iparent = index_of_parent( inst, instances.at( child ), instances.at( child )->_seeds.at(length+1), found ) ;
				assert ( found ) ;
				parent = inst.at( iparent ) ;
				PtrIllDefinedInstance r_instance_i = parent ;
				std::cout<<"Generator was "<<r_instance_i->seeds_as_string()<<std::endl;

				if ( !split_voxels( r_instance_i, instances.at( child ) ) ) {
					std::cerr<<"Problem @ line "<<__LINE__<<" "<<instances.at( child )->seeds_as_string()<<std::endl;
					for ( uint k=0;k<instances.at(child)->_seeds.size() ; k++ )
						std::cerr<<"\t"<<_illDefined[ instances.at(child)->_seeds.at(k) ].voxels_as_string()<<std::endl;
					std::cerr<<std::endl;
				}


				for ( uint without = 1 ; without <= length ; without++ ) {
					uint iparent = index_of_parent( inst, instances.at( child ), instances.at( child )->_seeds.at(without), found ) ;
					if ( found ) {
						parent = inst.at( iparent ) ;

						/// print one of the parent
						std::cout<<"\thas parent : "<<parent->seeds_as_string()<<std::endl;
						//std::cout<<"\t\tVoxels (before) : "<<parent->voxels_as_string()<<std::endl;
						/// remove child's voxels from parent
						if ( !split_voxels( parent, instances.at( child ) ) ) {
							std::cerr<<"Problem @ line "<<__LINE__<<" "<<instances.at( child )->seeds_as_string()<<std::endl;
							for ( uint k=0;k<instances.at(child)->_seeds.size() ; k++ )
								std::cerr<<"\t"<<_illDefined[ instances.at(child)->_seeds.at(k) ].voxels_as_string()<<std::endl;
							std::cerr<<std::endl;
						}
						//std::cout<<"\t\tVoxels (after) : "<<parent->voxels_as_string()<<std::endl;
						if ( watch_dog ) {
							uint idx_dbgvoxel = _illDefined[ parent->_seeds.at( 0 ) ]._voxels.indexOf( dbg_voxel ) ;
							std::cout<<"parent contains "<<dbg_voxel<<" ? "<<( parent->_idxVoxels.contains( idx_dbgvoxel ) ? "yes":"no")<<std::endl;
						}
					}
				}
				/// we first need to translate indices! (not the same initial set of voxels)
				iparent = index_of_parent( _illDefined[ r_instance_i->_seeds.at(1) ]._instances, instances.at( child ), r_instance_i->_seeds.at(0), found ) ;
				if ( found ) {
					parent = _illDefined[ r_instance_i->_seeds.at(1) ]._instances.at( iparent ) ;
					QList< uint > idx_child_tr ;
					translate_idxVoxel( instances.at(child)->_idxVoxels, r_instance_i->_seeds.at(0), r_instance_i->_seeds.at(1), idx_child_tr ) ;

					/// print one of the parent
					std::cout<<"\thas parent : "<<parent->seeds_as_string()<<std::endl;
					//std::cout<<"\t\tVoxels (before) : "<<parent->voxels_as_string()<<std::endl;
					//std::cout<<"\t\tAiming to remove : ";
					//std::copy( idx_child_tr.begin(), idx_child_tr.end(), std::ostream_iterator< uint32_t >( std::cout, " " ) ) ;
					//std::cout<<std::endl;
					/// remove child's voxels from parent
					if (!split_voxels( parent, idx_child_tr ) ) {
						std::cerr<<"Problem @ line "<<__LINE__<<" "<<instances.at( child )->seeds_as_string()<<std::endl;
	//					for ( uint k=0;k<instances.at(child)->_seeds.size() ; k++ )
	//						std::cerr<<"\t"<<_illDefined[ instances.at(child)->_seeds.at(k) ].voxels_as_string()<<std::endl;
	//					std::cerr<<std::endl;							
					}
						
					if ( watch_dog ) {
						uint idx_dbgvoxel = _illDefined[ parent->_seeds.at( 0 ) ]._voxels.indexOf( dbg_voxel ) ;
						std::cout<<"parent contains "<<dbg_voxel<<" ? "<<( parent->_idxVoxels.contains( idx_dbgvoxel ) ? "yes":"no")<<std::endl;
					}
						
				}
			}
		}
		iBegin = iEnd ;
		iEnd = instances.size() ;
	}

#else
	for ( typename QMap< Point, QList<V> >::ConstIterator iter = _ill_per_voxel.begin() ; iter != _ill_per_voxel.end() ; iter++ ) {
		if ( ! _illDefined.contains( iter.value().front() ) ) _illDefined.insert( iter.value().front(), IllDefined() ) ;
		IllDefined & main_seed = _illDefined[ iter.value().front() ] ;
		PtrIllDefinedInstance pInst = 0 ;
		for ( uint i_inst = 0 ; !pInst && i_inst < main_seed._instances.size() ; i_inst++ )
			if ( iter.value() == main_seed._instances.at( i_inst )->_seeds )
				pInst = main_seed._instances.at( i_inst ) ;
		bool new_inst = ( pInst == 0 ) ;
		if ( !pInst ) {
			pInst = new IllDefinedInstance() ;
			pInst->_seeds = iter.value() ;
		}
		for ( typename QList< V >::ConstIterator label = iter.value().begin() ; label != iter.value().end() ; label++ ) {
			if ( ! _illDefined.contains( *label ) ) _illDefined.insert( *label, IllDefined() ) ;
			IllDefined & cur_seed = _illDefined[ *label ] ;
			cur_seed._voxels.append( iter.key() ) ;
			if ( new_inst ) cur_seed._instances.append( pInst ) ;
		}
		pInst->_idxVoxels.append( main_seed._voxels.size()-1 ) ;
	}

#endif

	for ( typename QMap< uint32_t, IllDefined >::ConstIterator iter= _illDefined.begin();iter!= _illDefined.end();iter++ ) {
		int n = 0 ;
		for ( int i_inst=0;i_inst != iter.value()._instances.size();i_inst++) {
			const PtrIllDefinedInstance & inst = iter.value()._instances.at( i_inst ) ;
			n += inst->_idxVoxels.size() ;
		}
		std::cerr<<"Key "<<iter.key()<<" total "<<iter.value()._voxels.size() <<" distributed "<< n <<" "<<( n == iter.value()._voxels.size() ? "correct" : "wrong" ) << std::endl ;
		if ( n !=iter.value()._voxels.size() ) {
			explicit_missed_voxels( iter.key() ) ;
			for ( int i_inst=iter.value()._instances.size();i_inst != 0 ;i_inst--){
				const PtrIllDefinedInstance & inst = iter.value()._instances.at( i_inst-1 ) ;
				explicit_intersection( inst ) ;
			}
		}
	}
	post_processing();
	return true ;
}
template <typename T, typename U, typename V> 
void ConnexComponentRebuilder<T,U,V>::explicit_missed_voxels( uint32_t key ) const {
	typename QMap< uint32_t, IllDefined >::ConstIterator iter = _illDefined.constFind( key ) ;
	typename QMap< uint32_t, IllDefined >::ConstIterator ref ;
	QList< Point > distributedVoxels ;
	bool first_time = true ;
	Point dbg_voxel(213, 130, 80 ) ;
	
	for ( int i_inst=0;i_inst != iter.value()._instances.size();i_inst++) {
		const PtrIllDefinedInstance & inst = iter.value()._instances.at( i_inst ) ;
		ref = _illDefined.constFind( inst->_seeds.at(0) ) ;
		for ( uint v = 0 ; v < inst->_idxVoxels.size() ; v++ ) {
			if ( distributedVoxels.contains( ref.value()._voxels.at( inst->_idxVoxels.at( v ) ) ) && first_time ) {
				first_time = false ;
				std::cerr<<"[ Debug ] : voxel "<<ref.value()._voxels.at( inst->_idxVoxels.at( v ) )<<" will be duplicated! wrt "<<inst->seeds_as_string()<<std::endl ;
				std::cerr<<"            previous instances were :"<<std::endl;
				for ( int j_inst=0;j_inst<i_inst;j_inst++ )
					std::cerr<<"                 "<<iter.value()._instances.at( j_inst )->seeds_as_string()<<std::endl ;
				exit(666);
			}
			if ( ref.value()._voxels.at( inst->_idxVoxels.at( v ) ) == dbg_voxel ) std::cerr<<"[ Debug ] : Voxel "<<dbg_voxel<<" belongs to "<<inst->seeds_as_string()<<std::endl ;
			distributedVoxels.append( ref.value()._voxels.at( inst->_idxVoxels.at( v ) ) ) ;
		}
	}
	qSort( distributedVoxels ) ;
	std::cerr<<distributedVoxels.size()<<" gathered"<<std::endl;
	/// remove duplicates if any
	for ( uint v=0;v<distributedVoxels.size(); v++ )
		while ( (v+1) <distributedVoxels.size() ) {
			if ( distributedVoxels.at(v+1) ==distributedVoxels.at(v) )
				distributedVoxels.removeAt( v+1 ) ;
			else
				break ;
		}
	std::cerr<<distributedVoxels.size()<<" remaining after removing duplicates"<<std::endl;
	
	const QList< Point > & startingVoxels = iter.value()._voxels ;
	
	diff_sorted_list( distributedVoxels, "distributedVoxels", startingVoxels, "startingVoxels" ) ;
	
}


template <typename T, typename U, typename V> void ConnexComponentRebuilder<T,U,V>::set_voxels( const OutImage & img, const int * plane, const Point &seed, QList<Point> &crop, const Point &refPoint, U maxDist ) {
	QList<Point> L ;
	L.append( seed ) ;	
	assert( img.domain().isInside(seed) ) ;
	uint config_plane = (plane[0] != 0)*1 + (plane[1] != 0)*1 + (plane[2] != 0)*1 ;
	uint coord_not_null,
	     coord_null ;
	int  dnext ;
	Point pt ;
	bool is_touching ;
	if ( config_plane == 1 ) {
		coord_not_null = ( plane[0] != 0 ? 0 : ( plane[1] != 0 ? 1 : 2) ) ;
		dnext = 1 ;
		do {
			pt = seed ;
if ( g_debug ) std::cerr<<"[ Debug ] : "<<pt<<" @ line "<<__LINE__<<" d("<<refPoint<<") = "<<(pt-refPoint).dot( pt-refPoint )<<std::endl;
			do {
				pt.at( (coord_not_null+1)%3 ) += dnext ;
if ( g_debug ) std::cerr<<"[ Debug ] : "<<pt<<" @ line "<<__LINE__<<" d("<<refPoint<<") = "<<(pt-refPoint).dot( pt-refPoint )<<std::endl;
				if ( img.domain().isInside(pt) && (pt-refPoint).dot( pt-refPoint ) <= maxDist ) {
					is_touching = ( img(pt) != 0 ) ;
				} else
					is_touching = false ;
					if ( is_touching ) {
						L.append( pt ) ;
if ( g_debug ) std::cerr<<"[ Debug ] : "<<pt<<" @ line "<<__LINE__<<" ... will be removed"<<std::endl;
					}
			} while ( is_touching ) ;
			dnext *= -1 ;
		} while ( dnext < 0 ) ;
if ( g_debug ) std::cin>>dnext;
		while ( !L.isEmpty() ) {
			dnext = 1 ;
			do {
				pt = L.at(0) ;
if ( g_debug ) std::cerr<<"[ Debug ] : "<<pt<<" @ line "<<__LINE__<<" d("<<refPoint<<") = "<<(pt-refPoint).dot( pt-refPoint )<<std::endl;
				do {
					pt.at( (coord_not_null+2)%3 ) += dnext ;
if ( g_debug ) std::cerr<<"[ Debug ] : "<<pt<<" @ line "<<__LINE__<<" d("<<refPoint<<") = "<<(pt-refPoint).dot( pt-refPoint )<<std::endl;
					if ( img.domain().isInside(pt) && (pt-refPoint).dot( pt-refPoint ) <= maxDist ) {
						is_touching = ( img(pt) != 0 ) ;
					} else
						is_touching = false ;
					if ( is_touching ) {
						crop.append( pt ) ;
if ( g_debug ) std::cerr<<"[ Debug ] : "<<pt<<" @ line "<<__LINE__<<" ... will be removed"<<std::endl;
					}
				} while ( is_touching ) ;
				dnext *= -1 ;
			} while ( dnext < 0 ) ;
			if ( img( L.at(0) ) && (L.at(0)-refPoint).dot( L.at(0)-refPoint ) <= maxDist ) {
				crop.append( L.at(0) ) ;
				if ( g_debug ) std::cerr<<"[ Debug ] : "<<L.at(0)<<" @ line "<<__LINE__<<" ... will be removed"<<std::endl;
			}
			L.pop_front();
		}
if ( g_debug ) std::cin>>dnext;
	} else if ( config_plane == 2 ) {
		coord_null = ( plane[0] == 0 ? 0 : ( plane[1] == 0 ? 1 : 2) ) ;
		dnext = 1 ;
		do {
			pt = seed ;
if ( g_debug ) std::cerr<<"[ Debug ] : "<<pt<<" @ line "<<__LINE__<<" d("<<refPoint<<") = "<<(pt-refPoint).dot( pt-refPoint )<<std::endl;
			do {
				pt.at( (coord_null+1)%3 ) += /*plane[ (coord_null+1)%3 ]*plane[ (coord_null+2)%3 ]<0?dnext:dnext*/dnext;
				pt.at( (coord_null+2)%3 ) += plane[ (coord_null+1)%3 ]*plane[ (coord_null+2)%3 ]<0?dnext:-dnext;
if ( g_debug ) std::cerr<<"[ Debug ] : "<<pt<<" @ line "<<__LINE__<<" d("<<refPoint<<") = "<<(pt-refPoint).dot( pt-refPoint )<<std::endl;
				if ( img.domain().isInside(pt) && (pt-refPoint).dot( pt-refPoint ) <= maxDist ) {
					is_touching = ( img(pt) != 0 ) ;
				} else
					is_touching = false ;
					if ( is_touching ) {
						L.append( pt ) ;
if ( g_debug ) std::cerr<<"[ Debug ] : "<<pt<<" @ line "<<__LINE__<<" ... will be removed"<<std::endl;
					}
			} while ( is_touching ) ;
			dnext *= -1 ;
		} while ( dnext < 0 ) ;
if ( false ) std::cin>>dnext;
		while ( !L.isEmpty() ) {
			dnext = 1 ;
			do {
				pt = L.at(0) ;
if ( g_debug ) std::cerr<<"[ Debug ] : "<<pt<<" @ line "<<__LINE__<<" d("<<refPoint<<") = "<<(pt-refPoint).dot( pt-refPoint )<<std::endl;
				do {
					pt.at( coord_null ) += dnext ;
if ( g_debug ) std::cerr<<"[ Debug ] : "<<pt<<" @ line "<<__LINE__<<" d("<<refPoint<<") = "<<(pt-refPoint).dot( pt-refPoint )<<std::endl;
					if ( img.domain().isInside(pt) && (pt-refPoint).dot( pt-refPoint ) <= maxDist ) {
						is_touching = ( img(pt) != 0 ) ;
					} else
						is_touching = false ;
					if ( is_touching ) {
						crop.append( pt ) ;
if ( g_debug ) std::cerr<<"[ Debug ] : "<<pt<<" @ line "<<__LINE__<<" ... will be removed"<<std::endl;
					}
				} while ( is_touching ) ;
				dnext *= -1 ;
			} while ( dnext < 0 ) ;
			if ( img( L.at(0) ) && (L.at(0)-refPoint).dot( L.at(0)-refPoint ) <= maxDist ) {
				crop.append( L.at(0) ) ;
				if ( g_debug ) std::cerr<<"[ Debug ] : "<<L.at(0)<<" @ line "<<__LINE__<<" ... will be removed"<<std::endl;
			}
			L.pop_front();
if ( g_debug ) std::cin>>dnext;
		}
	} else {
		dnext = 1 ;
		do {
			pt = seed ;
if ( g_debug ) std::cerr<<"[ Debug ] : "<<pt<<" @ line "<<__LINE__<<" d("<<refPoint<<") = "<<(pt-refPoint).dot( pt-refPoint )<<std::endl;
			do {
				is_touching=false;
				for ( uint iBridge=0;iBridge<2;iBridge++ ) {
					bool is_touchingBridge ;
					pt.at(iBridge) += dnext * plane[iBridge] ;
					pt.at(2) = -( plane[3] + plane[0] * pt.at(0) + plane[1] * pt.at(1) ) / plane[2] ;
if ( g_debug ) std::cerr<<"[ Debug ] : "<<pt<<" @ line "<<__LINE__<<" d("<<refPoint<<") = "<<(pt-refPoint).dot( pt-refPoint )<<std::endl;
					if ( img.domain().isInside(pt) && (pt-refPoint).dot( pt-refPoint ) <= maxDist ) {
						is_touchingBridge = ( img(pt) != 0 ) ;
					} else
						is_touchingBridge = false ;
					if ( is_touchingBridge ) {
						L.append( pt ) ;
						is_touching=true;
if ( g_debug ) std::cerr<<"[ Debug ] : "<<pt<<" @ line "<<__LINE__<<" ... will be removed"<<std::endl;
					}
				}
				if ( g_debug ) {char c;std::cin>>c;}
			} while ( is_touching ) ;
			dnext *= -1 ;
		} while ( dnext < 0 ) ;
if ( g_debug ) std::cin>>dnext;
		while ( !L.isEmpty() ) {
			dnext = 1 ;
			do {
				pt = L.at(0) ;
if ( g_debug ) std::cerr<<"[ Debug ] : "<<pt<<" @ line "<<__LINE__<<" d("<<refPoint<<") = "<<(pt-refPoint).dot( pt-refPoint )<<std::endl;
				do {
					pt.at(0) += dnext * plane[0] ;
					pt.at(1) = -( plane[3] + plane[0] * pt.at(0) + plane[2] * pt.at(2) ) / plane[1] ;
if ( g_debug ) std::cerr<<"[ Debug ] : "<<pt<<" @ line "<<__LINE__<<" d("<<refPoint<<") = "<<(pt-refPoint).dot( pt-refPoint )<<std::endl;
					if ( img.domain().isInside(pt) && (pt-refPoint).dot( pt-refPoint ) <= maxDist ) {
						is_touching = ( img(pt) != 0 ) ;
					} else
						is_touching = false ;
					if ( is_touching ) {
						crop.append( pt ) ;
if ( g_debug ) std::cerr<<"[ Debug ] : "<<pt<<" @ line "<<__LINE__<<" ... will be removed"<<std::endl;
					}
				} while ( is_touching ) ;
				dnext *= -1 ;
			} while ( dnext < 0 ) ;
			if ( img( L.at(0) ) && (L.at(0)-refPoint).dot( L.at(0)-refPoint ) <= maxDist ) {
				crop.append( L.at(0) ) ;
				if ( g_debug ) std::cerr<<"[ Debug ] : "<<L.at(0)<<" @ line "<<__LINE__<<" ... will be removed"<<std::endl;
			}
			L.pop_front();
		}
if ( g_debug ) std::cin>>dnext;
	}
}


template <typename T, typename U, typename V> bool ConnexComponentRebuilder<T,U,V>::run( uint32_t selection, V color, bool storeOverlaping ) {
	if ( !_depth ) {
		std::cerr<<__FILE__<<" depth undefined"<<std::endl;
		return false ;
	}
	if ( !_layers.contains( selection ) ) {
		std::cerr<<__FILE__<<" missing layer "<<selection<<std::endl;
		return false ;
	}
	if ( !_lower.contains( selection ) )
		setBounds( selection ) ;
	
	if ( _layers[ selection ].first == 0 ) return true ;
	
	Domain domain( Point(0,0,0), _upper[ selection ] - _lower[ selection ]) ;
	Image 		*distances =new Image( domain ) ;
	const DigitalSet * pts = _layers[ selection ].first ;
	for ( DigitalSet::ConstIterator pt = pts->begin() ; pt != pts->end(); pt++ ) {
		Point ptShift = *pt ;
		ptShift -= _lower[selection] ;
		assert( ptShift.at(0)>=0&&ptShift.at(1)>=0&&ptShift.at(2)>=0);
		
		distances->setValue( ptShift, (*_depth)( (*pt).at(1),(*pt).at(0),(*pt).at(2) ) ) ;
	}
#ifdef SAFETY_MEMORY_CONSUPTION	
	if ( !_depthfile.isEmpty() ) {
		/// Temporarily free memory
		delete _depth ;
	}
#endif

	#if BUILD_INDIVIDUAL_COMP
	arma::icube thisCC( domain.upperBound().at(1), domain.upperBound().at(0), domain.upperBound().at(2) ) ;
	thisCC.fill(0);
	#endif
	OutImage componentDGImg( domain ) ;
	RDT rdt ;
	componentDGImg = rdt.reconstruction( *distances ) ;
	
	uint32_t volume = 0 ;
	for ( Domain::ConstIterator pt = domain.begin() ; pt != domain.end(); pt++ )
		if ( componentDGImg( *pt ) > 0 )
			volume++ ;
	_volumes[ selection ] = volume ;
	
	
	delete distances ;
#ifdef SAFETY_MEMORY_CONSUPTION
	if ( !_depthfile.isEmpty() ) {
		Pgm3dFactory< U > factory ;
		_depth = factory.read( _depthfile ) ;
		factory.correctEncoding( _depth ) ;
	}
#endif
	const Point & (*me)( const VoxelsPair &) ;
	const Point & (*other)( const VoxelsPair &) ;
	Point relative_loc_me, relative_loc_other ;
	Point::Component squared_distance_me, squared_distance_other ;
	const QSet<uint32_t> & relations = _adjacency[ selection ] ;
	std::cerr<<"Info ("<<__FUNCTION__<<" @ line "<<__LINE__<<" ) number of relations "<<relations.size()<<std::endl;
#ifdef OLD_REMOVAL_METHOD
	for ( Domain::ConstIterator pt = domain.begin() ; pt != domain.end(); pt++ ) {
		if ( componentDGImg( *pt ) > 0 ) {
			bool 	bInside = true ;
			for ( typename QSet<uint32_t>::ConstIterator adj_node = relations.begin() ; bInside && adj_node != relations.end() ; adj_node++ ) {
				if ( selection < *adj_node ) {
					me = &get_first ;
					other = &get_second ;
				} else {
					other = &get_first ;
					me = &get_second ;					
				}
				uint32_t key = std::min( *adj_node, selection ) * _n_labels + std::max( *adj_node, selection ) ;
				for ( QList< VoxelsPair >::ConstIterator loc = _locations[ key ].begin() ; bInside && loc != _locations[ key ].end() ; loc++ ) {
					relative_loc_me = *pt + _lower[ selection ] - (*me)( *loc ) ;
					squared_distance_me = relative_loc_me.dot( relative_loc_me ) ;
					relative_loc_other = *pt + _lower[ selection ] - (*other)(*loc) ;
					squared_distance_other = relative_loc_other.dot( relative_loc_other ) ;
					/// \note should check that this voxel is touching the separating plane
					if ( squared_distance_other > (*_depth)( (*other)(*loc).at(1),(*other)(*loc).at(0),(*other)(*loc).at(2) ) ) continue ;
					
					if ( squared_distance_me > (*_depth)( (*me)(*loc).at(1),(*me)(*loc).at(0),(*me)(*loc).at(2) ) ) { bInside = false ; continue ; }
					if ( squared_distance_other < squared_distance_me ) bInside = false ;
				}
			}
			if ( bInside ) {
				#if BUILD_INDIVIDUAL_COMP
				if ( _result( (*pt).at(1)+_lower[selection].at(1),(*pt).at(0)+_lower[selection].at(0),(*pt).at(2)+_lower[selection].at(2) ) ) {
					
					thisCC( (*pt).at(1), (*pt).at(0),(*pt).at(2) ) = 2 ;
				} else {
					thisCC( (*pt).at(1), (*pt).at(0),(*pt).at(2) ) = 1 ;
				}
				#endif
				_result( (*pt).at(1)+_lower[selection].at(1),(*pt).at(0)+_lower[selection].at(0),(*pt).at(2)+_lower[selection].at(2) ) = color ;
			}
		}
	}
#else ///#ifdef OLD_REMOVAL_METHOD
	int plane[4] ;
	int plane_intermediate[4] ;
	
	#ifdef DEBUG_REMOVAL_EXT
	BillonTpl< arma::u16 > historyRemoval( domain.upperBound().at(1)+1, domain.upperBound().at(0)+1, domain.upperBound().at(2)+1 ) ;
	historyRemoval.fill(0) ;
	arma::u16 today = 1 ;
	#endif
	QList<Point> toRemove ;
	for ( typename QSet<uint32_t>::ConstIterator adj_node = relations.begin() ; adj_node != relations.end() ; adj_node++ ) {
		if ( selection < *adj_node ) {
			me = &get_first ;
			other = &get_second ;
		} else {
			other = &get_first ;
			me = &get_second ;					
		}
		uint32_t key = std::min( *adj_node, selection ) * _n_labels + std::max( *adj_node, selection ) ;
		for ( QList< VoxelsPair >::ConstIterator loc = _locations[ key ].begin() ; loc != _locations[ key ].end() ; loc++ ) {
			Point frontier_dep = (*other)(*loc) - (*me)(*loc) ;
			plane[0] = frontier_dep.at(0) ;
			plane[1] = frontier_dep.at(1) ;
			plane[2] = frontier_dep.at(2) ;
			plane[3] = - (  plane[0] * ((*other)(*loc).at(0)-_lower[ selection ].at(0)) 
			              + plane[1] * ((*other)(*loc).at(1)-_lower[ selection ].at(1)) 
			              + plane[2] * ((*other)(*loc).at(2)-_lower[ selection ].at(2)) ) ;
if ( g_debug ) std::cerr<<"[ Debug ] : "<<plane[0]<<" "<<plane[1]<<" "<<plane[2]<<" "<<plane[3]<<" function "<<__FUNCTION__<<" @ line "<<__LINE__<<std::endl;
if ( g_debug ) std::cerr<<"[ Debug ] : "<<(*other)(*loc)<<" (depth "<< (*_depth)((*other)(*loc).at(1),(*other)(*loc).at(0),(*other)(*loc).at(2))<<") versus "<<(*me)(*loc)<<" (depth "<< (*_depth)((*me)(*loc).at(1),(*me)(*loc).at(0),(*me)(*loc).at(2))<<")"<<std::endl;
			QList<Point> crop ;
			set_voxels( componentDGImg, plane, (*other)(*loc)-_lower[ selection ], crop, (*me)(*loc)-_lower[ selection ], (*_depth)((*me)(*loc).at(1),(*me)(*loc).at(0),(*me)(*loc).at(2)) ) ;
			Point new_ref = (*other)(*loc)-_lower[ selection ] ;
			uint shift_coord = 0 ;
			uint config_plane = (plane[0] != 0 )*1 +(plane[1] != 0 )*1+(plane[2] != 0 )*1 ;
			
			do {
				toRemove.append( crop ) ;
				crop.clear() ;
				for ( shift_coord = 0 ; shift_coord < 3 ; shift_coord++ ) {
					if ( plane[ shift_coord ] == 0 ) continue ;
					new_ref.at( shift_coord ) += plane[ shift_coord ] ;
					memcpy( plane_intermediate, plane, sizeof(int)*3 ) ;
					plane_intermediate[3] = - ( plane_intermediate[0] * new_ref.at(0) + plane_intermediate[1] * new_ref.at(1) + plane_intermediate[2] * new_ref.at(2) ) ;
					if ( g_debug ) std::cerr<<"[ Debug ] : "<<plane_intermediate[0]<<" "<<plane_intermediate[1]<<" "<<plane_intermediate[2]<<" "<<plane_intermediate[3]<<" function "<<__FUNCTION__<<" @ line "<<__LINE__<<std::endl;
					if ( componentDGImg.domain().isInside( new_ref ) )
						set_voxels( componentDGImg, plane_intermediate, new_ref, crop, (*me)(*loc)-_lower[ selection ], (*_depth)((*me)(*loc).at(1),(*me)(*loc).at(0),(*me)(*loc).at(2)) ) ;

					#ifdef DEBUG_REMOVAL_EXT
					for ( uint iVoxel = 0 ; iVoxel < crop.size() ; iVoxel++ )
						if ( historyRemoval( crop.at(iVoxel).at(1),crop.at(iVoxel).at(0),crop.at(iVoxel).at(2) ) == 0 )
							historyRemoval( crop.at(iVoxel).at(1),crop.at(iVoxel).at(0),crop.at(iVoxel).at(2) ) = today ;
					#endif
				}
			} while ( !crop.isEmpty() ) ;
			if ( g_debug ) std::cerr<<"[ Debug ] : "<<toRemove.size()<<" voxels to remove function "<<__FUNCTION__<<" @ line "<<__LINE__<<std::endl;
		}
		#ifdef DEBUG_REMOVAL_EXT
		today++ ;
		if ( today == 0 ) std::cerr<<"[ Warning ] : used type is not big enough for storing the removal steps"<<std::endl;
		#endif
	}
	while ( !toRemove.isEmpty() ) {
		componentDGImg.setValue( toRemove.front(),0 ) ;
		toRemove.pop_front() ;
	}
	#ifdef DEBUG_REMOVAL_EXT
	today-- ;
	historyRemoval.setMaxValue( today ) ;
	IOPgm3d< arma::u16,qint16,false>::write( historyRemoval, QString( "/tmp/deletions-%1.pgm3d").arg( (int) selection ) ) ;
	#endif
	/// now, we can copy the image
int32_t nVoxels = 0 ;
	for ( Domain::ConstIterator pt = domain.begin() ; pt != domain.end(); pt++ )
		if ( componentDGImg( *pt ) > 0 ) {
			nVoxels++ ;
			Point ptShift( (*pt).at(0)+_lower[selection].at(0),(*pt).at(1)+_lower[selection].at(1),(*pt).at(2)+_lower[selection].at(2) ) ;
			if ( ptShift == Point(213, 130, 80) ) std::cerr<<"[ DEBUG VOXEL "<<ptShift.at(0)<<","<<ptShift.at(1)<<","<<ptShift.at(2)<<" : "<<color<<std::endl;
			if ( storeOverlaping )
				if ( _result( ptShift.at(1),ptShift.at(0),ptShift.at(2) ) > 0 ) {
#ifdef USE_MAP_FIRST_LABEL
					/// \todo should be easier to manage a QMap< Point, QList< V > > !
					if ( !_sharedVoxels.contains( /*color*/_result( ptShift.at(1),ptShift.at(0),ptShift.at(2) ) ) )
						_sharedVoxels.insert( /*color*/_result( ptShift.at(1),ptShift.at(0),ptShift.at(2) ), QMap< uint32_t, QList<Point> > () ) ;
					if ( !_sharedVoxels[ /*color*/_result( ptShift.at(1),ptShift.at(0),ptShift.at(2) ) ].contains( color/*_result( ptShift.at(1),ptShift.at(0),ptShift.at(2) )*/ ) )
						_sharedVoxels[ /*color*/_result( ptShift.at(1),ptShift.at(0),ptShift.at(2) ) ].insert( /*_result( ptShift.at(1),ptShift.at(0),ptShift.at(2) )*/color, QList<Point> () ) ;
					_sharedVoxels[ /*color*/_result( ptShift.at(1),ptShift.at(0),ptShift.at(2) ) ][ /*_result( ptShift.at(1),ptShift.at(0),ptShift.at(2) )*/color ].append( ptShift ) ;
#endif
					if ( !_ill_per_voxel.contains( ptShift ) ) {
						_ill_per_voxel.insert( ptShift, QList< V > () ) ;
						_ill_per_voxel[ ptShift ].append( _result( ptShift.at(1),ptShift.at(0),ptShift.at(2) ) ) ;
					}
					_ill_per_voxel[ ptShift ].append( color ) ;
					continue ; // no overwrite, important!
				}
			_result( ptShift.at(1),ptShift.at(0),ptShift.at(2) ) = color ;
		}
if ( g_debug ) std::cerr<<"[ Debug ] : "<<nVoxels<<" voxels remaining function "<<__FUNCTION__<<" @ line "<<__LINE__<<std::endl;
#endif
	#if BUILD_INDIVIDUAL_COMP
	IOPgm3d<int,qint8,false>::write( thisCC, QString( "/tmp/cc%1.pgm3d" ).arg( (int)color ) ) ;
	std::cerr<<"CC "<<(int)color<<" : "<<accu( thisCC )<<std::endl;
	#endif
	//std::cerr<<"Info ("<<__FUNCTION__<<" @ line "<<__LINE__<<" ) copy done "<<selection<<std::endl;
	return true ;
}

