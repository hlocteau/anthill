#define Y_ADJ( voxel, neighbor ) (voxel).at(1) + (neighbor/9-1)
#define X_ADJ( voxel, neighbor ) (voxel).at(0) + ( (neighbor%9)/3 -1 )
#define Z_ADJ( voxel, neighbor ) (voxel).at(2) + ( neighbor % 3 -1 )

bool g_debug = true ;

template <typename T, typename U, typename V> ConnexComponentRebuilder<T,U,V>::~ConnexComponentRebuilder( ) {
	if ( _allocated_depth ) delete _depth ;
	
	for ( QMap< uint32_t, LayerType >::Iterator iter = _layers.begin() ; iter != _layers.end() ; iter++ ) {
		delete iter.value().first ;	/// digitalset
		delete iter.value().second ;/// domain
	}
}

template <typename T, typename U, typename V> bool ConnexComponentRebuilder<T,U,V>::setDepth( BillonTpl< U > *depth ) {
	if ( _depth ) {
		if ( _allocated_depth ) delete _depth ;
	}
	_depth = depth ;
	_allocated_depth = false ;
	if ( _depth->n_rows != _n_rows || _depth->n_cols != _n_cols || _depth->n_slices != _n_slices ) {
		std::cerr<<"Warning : depth image's size ["<< _depth->n_rows<<" x "<< _depth->n_cols<<" x "<<_depth->n_slices<<"] is not equal"
				<<"to labelled skeleton image's size ["<<_n_rows<<" x "<<_n_cols<<" x "<<_n_slices<<"]"<<std::endl;
		return false ;
	}
	return true ;
}

template <typename T, typename U, typename V> bool ConnexComponentRebuilder<T,U,V>::setDepth( const QString & depthFileName ) {
	if ( _depth ) {
		if ( _allocated_depth ) delete _depth ;
	}
	Pgm3dFactory< U > factory ;
	_depth = factory.read( depthFileName ) ;
	factory.correctEncoding( _depth ) ;
	_allocated_depth = true ;
	if ( _depth->n_rows != _n_rows || _depth->n_cols != _n_cols || _depth->n_slices != _n_slices ) {
		std::cerr<<"Warning : depth image's size ["<< _depth->n_rows<<" x "<< _depth->n_cols<<" x "<<_depth->n_slices<<"] is not equal"
				<<"to labelled skeleton image's size ["<<_n_rows<<" x "<<_n_cols<<" x "<<_n_slices<<"]"<<std::endl;
		return false ;
	}
	_depthfile = depthFileName ;
	return true ;
}

template <typename T, typename U, typename V> bool ConnexComponentRebuilder<T,U,V>::setBounds( uint32_t selection ) {
	if ( !_depth ) return false ;
		
	Point 	lower=_layers[ selection ].second->lowerBound(),
			upper=_layers[ selection ].second->upperBound() ;
	const DigitalSet * pts = _layers[ selection ].first ;
	for ( DigitalSet::ConstIterator pt = pts->begin() ; pt != pts->end(); pt++ ) {
		U d = floor( 1.+sqrt( double( (*_depth)( (*pt).at(1),(*pt).at(0),(*pt).at(2) ) ) ) ) ;
		if ( (U)pt->at(0) - d < (U)lower.at(0) ) lower.at(0) = (U)pt->at(0) - d ;
		if ( (U)pt->at(1) - d < (U)lower.at(1) ) lower.at(1) = (U)pt->at(1) - d ;
		if ( (U)pt->at(2) - d < (U)lower.at(2) ) lower.at(2) = (U)pt->at(2) - d ;
		if ( (U)pt->at(0) + d > (U)upper.at(0) ) upper.at(0) = (U)pt->at(0) + d ;
		if ( (U)pt->at(1) + d > (U)upper.at(1) ) upper.at(1) = (U)pt->at(1) + d ;
		if ( (U)pt->at(2) + d > (U)upper.at(2) ) upper.at(2) = (U)pt->at(2) + d ;
	}
	_lower[ selection ] = lower ;
	_upper[ selection ] = upper ;
	
/// explain the bounds being found
for ( DigitalSet::ConstIterator pt = pts->begin() ; false && pt != pts->end(); pt++ ) {
	if ( lower.at(0) == pt->at(0) - (*_depth)( (*pt).at(1),(*pt).at(0),(*pt).at(2) ) ) std::cout<<"Xmin "<<lower.at(0)<<"="<<pt->at(0)<<"-"<<(*_depth)( (*pt).at(1),(*pt).at(0),(*pt).at(2) )<<std::endl;
	if ( lower.at(1) == pt->at(1) - (*_depth)( (*pt).at(1),(*pt).at(0),(*pt).at(2) ) ) std::cout<<"Ymin "<<lower.at(1)<<"="<<pt->at(1)<<"-"<<(*_depth)( (*pt).at(1),(*pt).at(0),(*pt).at(2) )<<std::endl;
	if ( lower.at(2) == pt->at(2) - (*_depth)( (*pt).at(1),(*pt).at(0),(*pt).at(2) ) ) std::cout<<"Zmin "<<lower.at(2)<<"="<<pt->at(2)<<"-"<<(*_depth)( (*pt).at(1),(*pt).at(0),(*pt).at(2) )<<std::endl;
	if ( upper.at(0) == pt->at(0) + (*_depth)( (*pt).at(1),(*pt).at(0),(*pt).at(2) ) ) std::cout<<"Xmax "<<upper.at(0)<<"="<<pt->at(0)<<"+"<<(*_depth)( (*pt).at(1),(*pt).at(0),(*pt).at(2) )<<std::endl;
	if ( upper.at(1) == pt->at(1) + (*_depth)( (*pt).at(1),(*pt).at(0),(*pt).at(2) ) ) std::cout<<"Ymax "<<upper.at(1)<<"="<<pt->at(1)<<"+"<<(*_depth)( (*pt).at(1),(*pt).at(0),(*pt).at(2) )<<std::endl;
	if ( upper.at(2) == pt->at(2) + (*_depth)( (*pt).at(1),(*pt).at(0),(*pt).at(2) ) ) std::cout<<"Zmax "<<upper.at(2)<<"="<<pt->at(2)<<"+"<<(*_depth)( (*pt).at(1),(*pt).at(0),(*pt).at(2) )<<std::endl;
}
	return true ;
}

template <typename T, typename U, typename V> ConnexComponentRebuilder<T,U,V>::ConnexComponentRebuilder( const BillonTpl<T> & img ) : _result( img.n_rows, img.n_cols, img.n_slices ) {
	_n_labels = img.max() + 1 ;
	_depth = 0 ;
	_allocated_depth = false ;
	_n_rows = img.n_rows ;
	_n_cols = img.n_cols ;
	_n_slices = img.n_slices ;
	_result.fill(0);
	init( img ) ;
}

template <typename T, typename U, typename V> ConnexComponentRebuilder<T,U,V>::ConnexComponentRebuilder( const QString & lblSkelFileName ) {
	
	Pgm3dFactory< T > factory ;
	BillonTpl< T > * pimg = factory.read( lblSkelFileName ) ;
	_n_labels = pimg->max() + 1 ;
	_depth = 0 ;
	_allocated_depth = false ;
	_n_rows = pimg->n_rows ;
	_n_cols = pimg->n_cols ;
	_n_slices = pimg->n_slices ;
	_result = BillonTpl<V>( _n_rows, _n_cols, _n_slices ) ;
	_result.fill(0);
	init( *pimg ) ;
	delete pimg ;
}

template <typename T, typename U, typename V> void ConnexComponentRebuilder<T,U,V>::init( const BillonTpl< T > &img ) {
	Point *lower = new Point [ _n_labels ] ;
	Point *upper = new Point [ _n_labels ] ;
	uint32_t label ;
	for ( label = 1 ; label < _n_labels ; label++ ) {
		lower[ label ] = Point ( _n_cols, _n_rows, _n_slices ) ;
		upper[ label ] = Point ( 0, 0, 0 ) ;
	}

	QList< iCoord3D > *pts = new QList< iCoord3D > [ _n_labels ] ;
	register int x,y,z ;
	for ( z = 0 ; z < _n_slices ; z++ )
		for ( x = 0 ; x < _n_cols ; x++ )
			for ( y = 0 ; y < _n_rows ; y++ ) {
				label = img(y,x,z) ;
				if ( label == 0 ) continue ;
				pts[ label ].append( iCoord3D(x,y,z) ) ;
				lower[ label ].at(0) = std::min( lower[ label ].at(0), x ) ;
				lower[ label ].at(1) = std::min( lower[ label ].at(1), y ) ;
				lower[ label ].at(2) = std::min( lower[ label ].at(2), z ) ;
				upper[ label ].at(0) = std::max( upper[ label ].at(0), x ) ;
				upper[ label ].at(1) = std::max( upper[ label ].at(1), y ) ;
				upper[ label ].at(2) = std::max( upper[ label ].at(2), z ) ;
			}
	
	for ( label = 1 ; label < _n_labels ; label++ ) {
		LayerType layer ;
		layer.second = new Domain( lower[label], upper[label] ) ;
		layer.first  = new DigitalSet( * layer.second ) ;
		_layers[ label ] = layer ;
		while ( !pts[ label ].empty() ) {
			iCoord3D aPoint = pts[ label ].takeAt(0);
			layer.first->insertNew( Point( aPoint.x,aPoint.y, aPoint.z ) ) ;
		}
	}
	delete [] lower ;
	delete [] upper ;

	/// adjacency relations
	uint32_t adj_label ;
	register int n ;
	for ( uint32_t label = 1 ; label < _n_labels ; label++ ) {
		const DigitalSet *pts = _layers[ label ].first ;
		for ( DigitalSet::Iterator pt = pts->begin() ; pt != pts->end() ; pt++ )
			for ( n = 0 ; n < 27 ; n++ ) {
				if ( n == 13 ) continue ; /// this is *pt
				x = X_ADJ( *pt, n ) ;
				if ( x < 0 || x == _n_cols ) continue ;
				y = Y_ADJ( *pt, n ) ;
				if ( y < 0 || y == _n_rows ) continue ;
				z = Z_ADJ( *pt, n ) ;
				if ( z < 0 || z == _n_slices ) continue ;
				adj_label = img(y,x,z) ;
				if ( adj_label <= label ) continue ;
				uint32_t key = label * _n_labels + adj_label ;
				
				if ( !_adjacency.contains( label ) ) _adjacency.insert( label, QSet<uint32_t>() ) ;
				if ( !_adjacency[ label ].contains( adj_label ) ) {
					_adjacency[ label ].insert( adj_label ) ;
					_locations.insert( key, QList< VoxelsPair > () ) ;
				}
				_locations[ key ].append( VoxelsPair( *pt, Point(x,y,z) ) ) ;
				if ( !_adjacency.contains( adj_label ) ) _adjacency.insert( adj_label, QSet<uint32_t>() ) ;
				if ( !_adjacency[ adj_label ].contains( label ) ) {
					_adjacency[ adj_label ].insert( label ) ;
				}
			}
	}


}

template <typename T, typename U, typename V> bool ConnexComponentRebuilder<T,U,V>::run( ) {
	for ( uint32_t label = 1 ; label < _n_labels ; label++ )
		if ( !run( label, label ) ) return false ;
	return true ;
}

template <typename T, typename U, typename V> void ConnexComponentRebuilder<T,U,V>::set_voxels( const OutImage & img, const int * plane, const Point &seed, QList<Point> &crop, const Point &refPoint, U maxDist ) {
	QList<Point> L ;
	L.append( seed ) ;	
	assert( img.domain().isInside(seed) ) ;
	uint config_plane = (plane[0] != 0)*1 + (plane[1] != 0)*1 + (plane[2] != 0)*1 ;
	uint coord_not_null,
	     coord_null ;
	int  dnext ;
	Point pt ;
	bool is_touching ;
	if ( config_plane == 1 ) {
		coord_not_null = ( plane[0] != 0 ? 0 : ( plane[1] != 0 ? 1 : 2) ) ;
		dnext = 1 ;
		do {
			pt = seed ;
if ( g_debug ) std::cerr<<"[ Debug ] : "<<pt<<" @ line "<<__LINE__<<std::endl;
			do {
				pt.at( (coord_not_null+1)%3 ) += dnext ;
if ( g_debug ) std::cerr<<"[ Debug ] : "<<pt<<" @ line "<<__LINE__<<std::endl;
				if ( img.domain().isInside(pt) && pt.dot( refPoint ) <= maxDist ) {
					is_touching = ( img(pt) != 0 ) ;
				} else
					is_touching = false ;
					if ( is_touching ) {
						L.append( pt ) ;
if ( g_debug ) std::cerr<<"[ Debug ] : "<<pt<<" @ line "<<__LINE__<<" ... will be removed"<<std::endl;
					}
			} while ( is_touching ) ;
			dnext *= -1 ;
		} while ( dnext < 0 ) ;
if ( false ) std::cin>>dnext;
		while ( !L.isEmpty() ) {
			dnext = 1 ;
			do {
				pt = L.at(0) ;
if ( g_debug ) std::cerr<<"[ Debug ] : "<<pt<<" @ line "<<__LINE__<<std::endl;
				do {
					pt.at( (coord_not_null+2)%3 ) += dnext ;
if ( g_debug ) std::cerr<<"[ Debug ] : "<<pt<<" @ line "<<__LINE__<<std::endl;
					if ( img.domain().isInside(pt) && pt.dot( refPoint ) <= maxDist ) {
						is_touching = ( img(pt) != 0 ) ;
					} else
						is_touching = false ;
					if ( is_touching ) {
						L.append( pt ) ;
if ( g_debug ) std::cerr<<"[ Debug ] : "<<pt<<" @ line "<<__LINE__<<" ... will be removed"<<std::endl;
					}
				} while ( is_touching ) ;
				dnext *= -1 ;
			} while ( dnext < 0 ) ;
			crop.append( L.takeFirst() ) ;
		}
if ( false ) std::cin>>dnext;
	} else if ( config_plane == 2 ) {
		coord_null = ( plane[0] == 0 ? 0 : ( plane[1] == 0 ? 1 : 2) ) ;
		dnext = 1 ;
		do {
			pt = seed ;
if ( g_debug ) std::cerr<<"[ Debug ] : "<<pt<<" @ line "<<__LINE__<<std::endl;
			do {
				pt.at( (coord_null+1)%3 ) += dnext * plane[ (coord_null+1)%3 ];
				pt.at( (coord_null+2)%3 ) += dnext * plane[ (coord_null+2)%3 ];
if ( g_debug ) std::cerr<<"[ Debug ] : "<<pt<<" @ line "<<__LINE__<<std::endl;
				if ( img.domain().isInside(pt) && pt.dot( refPoint ) <= maxDist ) {
					is_touching = ( img(pt) != 0 ) ;
				} else
					is_touching = false ;
					if ( is_touching ) {
						L.append( pt ) ;
if ( g_debug ) std::cerr<<"[ Debug ] : "<<pt<<" @ line "<<__LINE__<<" ... will be removed"<<std::endl;
					}
			} while ( is_touching ) ;
			dnext *= -1 ;
		} while ( dnext < 0 ) ;
if ( false ) std::cin>>dnext;
		while ( !L.isEmpty() ) {
			dnext = 1 ;
			do {
				pt = L.at(0) ;
if ( g_debug ) std::cerr<<"[ Debug ] : "<<pt<<" @ line "<<__LINE__<<std::endl;
				do {
					pt.at( coord_null ) += dnext ;
if ( g_debug ) std::cerr<<"[ Debug ] : "<<pt<<" @ line "<<__LINE__<<std::endl;
					if ( img.domain().isInside(pt) && pt.dot( refPoint ) <= maxDist ) {
						is_touching = ( img(pt) != 0 ) ;
					} else
						is_touching = false ;
					if ( is_touching ) {
						L.append( pt ) ;
if ( g_debug ) std::cerr<<"[ Debug ] : "<<pt<<" @ line "<<__LINE__<<" ... will be removed"<<std::endl;
					}
				} while ( is_touching ) ;
				dnext *= -1 ;
			} while ( dnext < 0 ) ;
			crop.append( L.takeFirst() ) ;
if ( false ) std::cin>>dnext;
		}
	} else {
		dnext = 1 ;
		do {
			pt = seed ;
if ( g_debug ) std::cerr<<"[ Debug ] : "<<pt<<" @ line "<<__LINE__<<std::endl;
			do {
				pt.at(0) += dnext * plane[0] ;
				pt.at(1) += dnext * plane[1] ;
				pt.at(2) = -( plane[3] + plane[0] * pt.at(0) + plane[1] * pt.at(1) ) / plane[2] ;
if ( g_debug ) std::cerr<<"[ Debug ] : "<<pt<<" @ line "<<__LINE__<<std::endl;
				if ( img.domain().isInside(pt) && pt.dot( refPoint ) <= maxDist ) {
					is_touching = ( img(pt) != 0 ) ;
				} else
					is_touching = false ;
				if ( is_touching ) {
					L.append( pt ) ;
if ( g_debug ) std::cerr<<"[ Debug ] : "<<pt<<" @ line "<<__LINE__<<" ... will be removed"<<std::endl;
				}
			} while ( is_touching ) ;
			dnext *= -1 ;
		} while ( dnext < 0 ) ;
if ( false ) std::cin>>dnext;
		while ( !L.isEmpty() ) {
			dnext = 1 ;
			do {
				pt = L.at(0) ;
if ( g_debug ) std::cerr<<"[ Debug ] : "<<pt<<" @ line "<<__LINE__<<std::endl;
				do {
					pt.at(0) += dnext * plane[0] ;
					pt.at(1) = -( plane[3] + plane[0] * pt.at(0) + plane[2] * pt.at(2) ) / plane[1] ;
if ( g_debug ) std::cerr<<"[ Debug ] : "<<pt<<" @ line "<<__LINE__<<std::endl;
					if ( img.domain().isInside(pt) && pt.dot( refPoint ) <= maxDist ) {
						is_touching = ( img(pt) != 0 ) ;
					} else
						is_touching = false ;
					if ( is_touching ) {
						L.append( pt ) ;
if ( g_debug ) std::cerr<<"[ Debug ] : "<<pt<<" @ line "<<__LINE__<<" ... will be removed"<<std::endl;
					}
				} while ( is_touching ) ;
				dnext *= -1 ;
			} while ( dnext < 0 ) ;
			crop.append( L.takeFirst() ) ;
		}
if ( false ) std::cin>>dnext;
	}
}


template <typename T, typename U, typename V> bool ConnexComponentRebuilder<T,U,V>::run( uint32_t selection, V color ) {
	if ( !_depth ) {
		std::cerr<<__FILE__<<" depth undefined"<<std::endl;
		return false ;
	}
	if ( !_layers.contains( selection ) ) {
		std::cerr<<__FILE__<<" missing layer "<<selection<<std::endl;
		return false ;
	}
	if ( !_lower.contains( selection ) )
		setBounds( selection ) ;
	Domain domain( Point(0,0,0), _upper[ selection ] - _lower[ selection ]) ;
	Image 		*distances =new Image( domain ) ;
	const DigitalSet * pts = _layers[ selection ].first ;
	for ( DigitalSet::ConstIterator pt = pts->begin() ; pt != pts->end(); pt++ ) {
		Point ptShift = *pt ;
		ptShift -= _lower[selection] ;
		assert( ptShift.at(0)>=0&&ptShift.at(1)>=0&&ptShift.at(2)>=0);
		
		distances->setValue( ptShift, (*_depth)( (*pt).at(1),(*pt).at(0),(*pt).at(2) ) ) ;
	}
#ifdef SAFETY_MEMORY_CONSUPTION	
	if ( !_depthfile.isEmpty() ) {
		/// Temporarily free memory
		delete _depth ;
	}
#endif

	#if BUILD_INDIVIDUAL_COMP
	arma::icube thisCC( domain.upperBound().at(1), domain.upperBound().at(0), domain.upperBound().at(2) ) ;
	thisCC.fill(0);
	#endif
	OutImage componentDGImg( domain ) ;
	RDT rdt ;
	componentDGImg = rdt.reconstruction( *distances ) ;
	delete distances ;
#ifdef SAFETY_MEMORY_CONSUPTION
	if ( !_depthfile.isEmpty() ) {
		Pgm3dFactory< U > factory ;
		_depth = factory.read( _depthfile ) ;
		factory.correctEncoding( _depth ) ;
	}
#endif
	const Point & (*me)( const VoxelsPair &) ;
	const Point & (*other)( const VoxelsPair &) ;
	Point relative_loc_me, relative_loc_other ;
	Point::Component squared_distance_me, squared_distance_other ;
	const QSet<uint32_t> & relations = _adjacency[ selection ] ;
	std::cerr<<"Info ("<<__FUNCTION__<<" @ line "<<__LINE__<<" ) number of relations "<<relations.size()<<std::endl;
#ifdef OLD_REMOVAL_METHOD
	for ( Domain::ConstIterator pt = domain.begin() ; pt != domain.end(); pt++ ) {
		if ( componentDGImg( *pt ) > 0 ) {
			bool 	bInside = true ;
			for ( typename QSet<uint32_t>::ConstIterator adj_node = relations.begin() ; bInside && adj_node != relations.end() ; adj_node++ ) {
				if ( selection < *adj_node ) {
					me = &get_first ;
					other = &get_second ;
				} else {
					other = &get_first ;
					me = &get_second ;					
				}
				uint32_t key = std::min( *adj_node, selection ) * _n_labels + std::max( *adj_node, selection ) ;
				for ( QList< VoxelsPair >::ConstIterator loc = _locations[ key ].begin() ; bInside && loc != _locations[ key ].end() ; loc++ ) {
					relative_loc_me = *pt + _lower[ selection ] - (*me)( *loc ) ;
					squared_distance_me = relative_loc_me.dot( relative_loc_me ) ;
					relative_loc_other = *pt + _lower[ selection ] - (*other)(*loc) ;
					squared_distance_other = relative_loc_other.dot( relative_loc_other ) ;
					/// \note should check that this voxel is touching the separating plane
					if ( squared_distance_other > (*_depth)( (*other)(*loc).at(1),(*other)(*loc).at(0),(*other)(*loc).at(2) ) ) continue ;
					
					if ( squared_distance_me > (*_depth)( (*me)(*loc).at(1),(*me)(*loc).at(0),(*me)(*loc).at(2) ) ) { bInside = false ; continue ; }
					if ( squared_distance_other < squared_distance_me ) bInside = false ;
				}
			}
			if ( bInside ) {
				#if BUILD_INDIVIDUAL_COMP
				if ( _result( (*pt).at(1)+_lower[selection].at(1),(*pt).at(0)+_lower[selection].at(0),(*pt).at(2)+_lower[selection].at(2) ) ) {
					
					thisCC( (*pt).at(1), (*pt).at(0),(*pt).at(2) ) = 2 ;
				} else {
					thisCC( (*pt).at(1), (*pt).at(0),(*pt).at(2) ) = 1 ;
				}
				#endif
				_result( (*pt).at(1)+_lower[selection].at(1),(*pt).at(0)+_lower[selection].at(0),(*pt).at(2)+_lower[selection].at(2) ) = color ;
			}
		}
	}
#else ///#ifdef OLD_REMOVAL_METHOD
	int plane[4] ;
	int plane_intermediate[4] ;
	
	#ifdef DEBUG_REMOVAL_EXT
	BillonTpl< arma::u16 > historyRemoval( domain.upperBound().at(1)+1, domain.upperBound().at(0)+1, domain.upperBound().at(2)+1 ) ;
	historyRemoval.fill(0) ;
	arma::u16 today = 1 ;
	#endif
	QList<Point> toRemove ;
	for ( typename QSet<uint32_t>::ConstIterator adj_node = relations.begin() ; adj_node != relations.end() ; adj_node++ ) {
		if ( selection < *adj_node ) {
			me = &get_first ;
			other = &get_second ;
		} else {
			other = &get_first ;
			me = &get_second ;					
		}
		uint32_t key = std::min( *adj_node, selection ) * _n_labels + std::max( *adj_node, selection ) ;
		for ( QList< VoxelsPair >::ConstIterator loc = _locations[ key ].begin() ; loc != _locations[ key ].end() ; loc++ ) {
			Point frontier_dep = (*other)(*loc) - (*me)(*loc) ;
			plane[0] = frontier_dep.at(0) ;
			plane[1] = frontier_dep.at(1) ;
			plane[2] = frontier_dep.at(2) ;
			plane[3] = - (  plane[0] * ((*other)(*loc).at(0)-_lower[ selection ].at(0)) 
			              + plane[1] * ((*other)(*loc).at(1)-_lower[ selection ].at(1)) 
			              + plane[2] * ((*other)(*loc).at(2)-_lower[ selection ].at(2)) ) ;
if ( g_debug ) std::cerr<<"[ Debug ] : "<<plane[0]<<" "<<plane[1]<<" "<<plane[2]<<" "<<plane[3]<<" function "<<__FUNCTION__<<" @ line "<<__LINE__<<std::endl;
if ( g_debug ) std::cerr<<"[ Debug ] : "<<(*other)(*loc)<<" (depth "<< (*_depth)((*other)(*loc).at(1),(*other)(*loc).at(0),(*other)(*loc).at(2))<<") versus "<<(*me)(*loc)<<" (depth "<< (*_depth)((*me)(*loc).at(1),(*me)(*loc).at(0),(*me)(*loc).at(2))<<")"<<std::endl;
			QList<Point> crop ;
			set_voxels( componentDGImg, plane, (*other)(*loc)-_lower[ selection ], crop, (*me)(*loc)-_lower[ selection ], (*_depth)((*me)(*loc).at(1),(*me)(*loc).at(0),(*me)(*loc).at(2)) ) ;
			Point new_ref = (*other)(*loc)-_lower[ selection ] ;
			uint shift_coord = 0 ;
			uint config_plane = (plane[0] != 0 )*1 +(plane[1] != 0 )*1+(plane[2] != 0 )*1 ;
			
			do {
				toRemove.append( crop ) ;
				crop.clear() ;
				for ( shift_coord = 0 ; shift_coord < config_plane ; shift_coord++ ) {
					if ( plane[ shift_coord ] == 0 ) continue ;
					new_ref.at( shift_coord ) += plane[ shift_coord ] ;
					memcpy( plane_intermediate, plane, sizeof(int)*3 ) ;
					plane_intermediate[3] = - ( plane_intermediate[0] * new_ref.at(0) + plane_intermediate[1] * new_ref.at(1) + plane_intermediate[2] * new_ref.at(2) ) ;
					if ( g_debug ) std::cerr<<"[ Debug ] : "<<plane_intermediate[0]<<" "<<plane_intermediate[1]<<" "<<plane_intermediate[2]<<" "<<plane_intermediate[3]<<" function "<<__FUNCTION__<<" @ line "<<__LINE__<<std::endl;
					if ( componentDGImg.domain().isInside( new_ref ) )
						set_voxels( componentDGImg, plane_intermediate, new_ref, crop, (*me)(*loc)-_lower[ selection ], (*_depth)((*me)(*loc).at(1),(*me)(*loc).at(0),(*me)(*loc).at(2)) ) ;

					#ifdef DEBUG_REMOVAL_EXT
					for ( uint iVoxel = 0 ; iVoxel < crop.size() ; iVoxel++ )
						if ( historyRemoval( crop.at(iVoxel).at(1),crop.at(iVoxel).at(0),crop.at(iVoxel).at(2) ) == 0 )
							historyRemoval( crop.at(iVoxel).at(1),crop.at(iVoxel).at(0),crop.at(iVoxel).at(2) ) = today ;
					today++ ;
					if ( today == 0 ) std::cerr<<"[ Warning ] : used type is not big enough for storing the removal steps"<<std::endl;
					#endif
				}
			} while ( !crop.isEmpty() ) ;
			if ( g_debug ) std::cerr<<"[ Debug ] : "<<toRemove.size()<<" voxels to remove function "<<__FUNCTION__<<" @ line "<<__LINE__<<std::endl;
		}
	}
	while ( !toRemove.isEmpty() ) {
		componentDGImg.setValue( toRemove.front(),0 ) ;
		toRemove.pop_front() ;
	}
	#ifdef DEBUG_REMOVAL_EXT
	today-- ;
	historyRemoval.setMaxValue( today ) ;
	IOPgm3d< arma::u16,qint16,false>::write( historyRemoval, QString( "/tmp/deletions-%1.pgm3d").arg( (int) selection ) ) ;
	#endif
	/// now, we can copy the image
int32_t nVoxels = 0 ;
	for ( Domain::ConstIterator pt = domain.begin() ; pt != domain.end(); pt++ )
		if ( componentDGImg( *pt ) > 0 ) {
			_result( (*pt).at(1)+_lower[selection].at(1),(*pt).at(0)+_lower[selection].at(0),(*pt).at(2)+_lower[selection].at(2) ) = color ;
			nVoxels++ ;
		}
if ( g_debug ) std::cerr<<"[ Debug ] : "<<nVoxels<<" voxels remaining function "<<__FUNCTION__<<" @ line "<<__LINE__<<std::endl;
#endif
	#if BUILD_INDIVIDUAL_COMP
	IOPgm3d<int,qint8,false>::write( thisCC, QString( "/tmp/cc%1.pgm3d" ).arg( (int)color ) ) ;
	std::cerr<<"CC "<<(int)color<<" : "<<accu( thisCC )<<std::endl;
	#endif
	//std::cerr<<"Info ("<<__FUNCTION__<<" @ line "<<__LINE__<<" ) copy done "<<selection<<std::endl;
	return true ;
}

